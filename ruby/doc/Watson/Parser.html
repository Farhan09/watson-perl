<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class Watson::Parser - RDoc Documentation</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/watson/parser.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link">Object
  
</nav>

    <!-- Included Modules -->
<nav id="includes-section" class="section">
  <h3 class="section-header">Included Modules</h3>

  <ul class="link-list">
  
  
    <li><a class="include" href="../Watson.html">Watson</a>
  
  
  </ul>
</nav>

    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-get_comment_type">#get_comment_type</a>
    
    <li ><a href="#method-i-parse_dir">#parse_dir</a>
    
    <li ><a href="#method-i-parse_file">#parse_file</a>
    
    <li ><a href="#method-i-run">#run</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    
    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../Watson.html">Watson</a>
  
    <li><a href="../Watson/Command.html">Watson::Command</a>
  
    <li><a href="../Watson/Config.html">Watson::Config</a>
  
    <li><a href="../Watson/FS.html">Watson::FS</a>
  
    <li><a href="../Watson/Parser.html">Watson::Parser</a>
  
    <li><a href="../Watson/Printer.html">Watson::Printer</a>
  
    <li><a href="../Watson/Remote.html">Watson::Remote</a>
  
    <li><a href="../Watson/Remote/Bitbucket.html">Watson::Remote::Bitbucket</a>
  
    <li><a href="../Watson/Remote/GitHub.html">Watson::Remote::GitHub</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class Watson::Parser</h1>

  <div id="description" class="description">
    
<p>Dir/File parser class Contains all necessary methods to parse through files
and directories  for specified tags and generate data structure containing
found issues</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="DEBUG">DEBUG
        
        <dd class="description"><p>Debug printing for this class</p>
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(config)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Initialize the parser with the current watson config</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/watson/parser.rb, line 20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">config</span>)
<span class="ruby-comment"># [review] - Not sure if passing config here is best way to access it</span>

        <span class="ruby-comment"># Identify method entry</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ self } : #{ __method__ }\n&quot;</span>
        
        <span class="ruby-ivar">@config</span> = <span class="ruby-identifier">config</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-get_comment_type" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_comment_type</span><span
            class="method-args">(filename)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Get comment syntax for given file</p>
          
          

          
          <div class="method-source-code" id="get_comment_type-source">
            <pre><span class="ruby-comment"># File lib/watson/parser.rb, line 352</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_comment_type</span>(<span class="ruby-identifier">filename</span>)

        <span class="ruby-comment"># Identify method entry</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ self } : #{ __method__ }\n&quot;</span>

        <span class="ruby-comment"># Grab the file extension (.something)</span>
        <span class="ruby-comment"># Check to see whether it is recognized and set comment type</span>
        <span class="ruby-comment"># If unrecognized, try to grab the next .something extension</span>
        <span class="ruby-comment"># This is to account for file.cpp.1 or file.cpp.bak, ect</span>

        <span class="ruby-comment"># [review] - Matz style while loop a la http://stackoverflow.com/a/10713963/1604424</span>
        <span class="ruby-comment"># Create _mtch var so we can access it outside of the do loop</span>

        <span class="ruby-identifier">_mtch</span> = <span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
                <span class="ruby-identifier">_mtch</span> = <span class="ruby-identifier">filename</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp">/(\.(\w+))$/</span>)
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Extension: #{ _mtch }\n&quot;</span>

                <span class="ruby-comment"># Break if we don&#39;t find a match </span>
                <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">_mtch</span>.<span class="ruby-identifier">nil?</span>

                <span class="ruby-comment"># Determine file type</span>
                <span class="ruby-keyword">case</span> <span class="ruby-identifier">_mtch</span>[<span class="ruby-value">0</span>]
                <span class="ruby-comment"># C / C++, Java, C#</span>
                <span class="ruby-comment"># [todo] - Add /* style comment</span>
                <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;.cpp&quot;</span>, <span class="ruby-string">&quot;.cc&quot;</span>, <span class="ruby-string">&quot;.c&quot;</span>, <span class="ruby-string">&quot;.hpp&quot;</span>, <span class="ruby-string">&quot;.h&quot;</span>,
                         <span class="ruby-string">&quot;.java&quot;</span>, <span class="ruby-string">&quot;.class&quot;</span>, <span class="ruby-string">&quot;.cs&quot;</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Comment type is: //\n&quot;</span>
                        <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;//&quot;</span>

                <span class="ruby-comment"># Bash, Ruby, Perl, Python</span>
                <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;.sh&quot;</span>, <span class="ruby-string">&quot;.rb&quot;</span>, <span class="ruby-string">&quot;.pl&quot;</span>, <span class="ruby-string">&quot;.py&quot;</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Comment type is: #\n&quot;</span>
                        <span class="ruby-keyword">return</span> <span class="ruby-node">&quot;#&quot;</span>

                <span class="ruby-comment"># Can&#39;t recognize extension, keep looping in case of .bk, .#, ect</span>
                <span class="ruby-keyword">else</span>
                        <span class="ruby-identifier">filename</span> = <span class="ruby-identifier">filename</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/(\.(\w+))$/</span>, <span class="ruby-string">&quot;&quot;</span>)
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Didn&#39;t recognize, searching #{ filename }\n&quot;</span>
                
                <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># We didn&#39;t find any matches from the filename, return error (0)</span>
        <span class="ruby-comment"># Deal with what default to use in calling method</span>
        <span class="ruby-comment"># [review] - Is Ruby convention to return 1 or 0 (or -1) on failure/error?</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Couldn&#39;t find any recognized extension type\n&quot;</span>
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> 
        
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_comment_type-source -->
          
        </div>

        

        
      </div><!-- get_comment_type-method -->

    
      <div id="method-i-parse_dir" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_dir</span><span
            class="method-args">(dir, depth)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse through specified directory and find all subdirs and files</p>
          
          

          
          <div class="method-source-code" id="parse_dir-source">
            <pre><span class="ruby-comment"># File lib/watson/parser.rb, line 68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">parse_dir</span>(<span class="ruby-identifier">dir</span>, <span class="ruby-identifier">depth</span>)

        <span class="ruby-comment"># Identify method entry</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ self } : #{ __method__ }\n&quot;</span>

        <span class="ruby-comment"># Error check on input</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-constant">Watson</span><span class="ruby-operator">::</span><span class="ruby-constant">FS</span>.<span class="ruby-identifier">check_dir</span>(<span class="ruby-identifier">dir</span>)
                <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;Unable to open #{ dir }, exiting\n&quot;</span>
                <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
        <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Opened #{ dir } for parsing\n&quot;</span>
        <span class="ruby-keyword">end</span>
        
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Parsing through all files/directories in #{ dir }\n&quot;</span>

        <span class="ruby-comment"># [review] - Shifted away from single Dir.glob loop to separate for dir/file</span>
        <span class="ruby-comment">#                     This duplicates code but is much better for readability</span>
        <span class="ruby-comment">#                     Not sure which is preferred?</span>
        

        <span class="ruby-comment"># Remove leading . or ./</span>
        <span class="ruby-identifier">_glob_dir</span> = <span class="ruby-identifier">dir</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/^\.(\/?)/</span>, <span class="ruby-string">&#39;&#39;</span>)
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;_glob_dir: #{_glob_dir}\n&quot;</span>
        

        <span class="ruby-comment"># Go through directory to find all files</span>
        <span class="ruby-comment"># Create new array to hold all parsed files</span>
        <span class="ruby-identifier">_completed_files</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-constant">Dir</span>.<span class="ruby-identifier">glob</span>(<span class="ruby-node">&quot;#{ _glob_dir }{*,.*}&quot;</span>).<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span> <span class="ruby-identifier">_fn</span> <span class="ruby-operator">|</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">file?</span>(<span class="ruby-identifier">_fn</span>) }.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_entry</span> <span class="ruby-operator">|</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Entry: #{_entry} is a file\n&quot;</span>  
        
        
                <span class="ruby-comment"># [review] - Warning to user when file is ignored? (outside of debug_print)</span>
                <span class="ruby-comment"># Check against ignore list, if match, set to &quot;&quot; which will be ignored</span>
                <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">ignore_list</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_ignore</span> <span class="ruby-operator">|</span>
                        <span class="ruby-comment"># [review] - Better &quot;Ruby&quot; way to check for &quot;*&quot;? </span>
                        <span class="ruby-comment"># [review] - Probably cleaner way to perform multiple checks below</span>
                        <span class="ruby-comment"># Look for *.type on list, regex to match entry</span>
                        <span class="ruby-keyword">if</span> <span class="ruby-identifier">_ignore</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-string">&quot;*&quot;</span>
                                <span class="ruby-identifier">_cut</span> = <span class="ruby-identifier">_ignore</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
                                <span class="ruby-keyword">if</span> <span class="ruby-identifier">_entry</span>.<span class="ruby-identifier">match</span>(<span class="ruby-node">/#{ _cut }/</span>)
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ _entry } is on the ignore list, setting to \&quot;\&quot;\n&quot;</span>
                                        <span class="ruby-identifier">_entry</span> = <span class="ruby-string">&quot;&quot;</span>
                                        <span class="ruby-keyword">break</span>
                                <span class="ruby-keyword">end</span>
                        <span class="ruby-comment"># Else check for verbose ignore match</span>
                        <span class="ruby-keyword">else</span>
                                <span class="ruby-keyword">if</span>  <span class="ruby-identifier">_entry</span>  <span class="ruby-operator">==</span> <span class="ruby-identifier">_ignore</span> <span class="ruby-operator">||</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">absolute_path</span>(<span class="ruby-identifier">_entry</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">_ignore</span>
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ _entry } is on the ignore list, setting to \&quot;\&quot;\n&quot;</span>
                                        <span class="ruby-identifier">_entry</span> = <span class="ruby-string">&quot;&quot;</span>
                                        <span class="ruby-keyword">break</span>
                                <span class="ruby-keyword">end</span>
                        <span class="ruby-keyword">end</span>
                <span class="ruby-keyword">end</span> 

                <span class="ruby-comment"># If the resulting entry (after filtering) isn&#39;t empty, parse it and push into file array</span>
                <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">_entry</span>.<span class="ruby-identifier">empty?</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Parsing #{ _entry }\n&quot;</span>
                        <span class="ruby-identifier">_completed_files</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">parse_file</span>(<span class="ruby-identifier">_entry</span>))
                <span class="ruby-keyword">end</span> 
        
        <span class="ruby-keyword">end</span>
                 
        
        <span class="ruby-comment"># Go through directory to find all subdirs</span>
        <span class="ruby-comment"># Create new array to hold all parsed subdirs </span>
        <span class="ruby-identifier">_completed_dirs</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-constant">Dir</span>.<span class="ruby-identifier">glob</span>(<span class="ruby-node">&quot;#{ _glob_dir }{*, .*}&quot;</span>).<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span> <span class="ruby-identifier">_fn</span> <span class="ruby-operator">|</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">directory?</span>(<span class="ruby-identifier">_fn</span>) }.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_entry</span> <span class="ruby-operator">|</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Entry: #{ _entry } is a dir\n&quot;</span> 
                        
                

                <span class="ruby-comment">## Depth limit logic</span>
                <span class="ruby-comment"># Current depth is depth of previous parse_dir (passed in as second param) + 1</span>
                <span class="ruby-identifier">_cur_depth</span> = <span class="ruby-identifier">depth</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Current Folder depth: #{ _cur_depth }\n&quot;</span>
                
                <span class="ruby-comment"># If Config.parse_depth is 0, no limit on subdir parsing</span>
                <span class="ruby-keyword">if</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">parse_depth</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;No max depth, parsing directory\n&quot;</span>
                        <span class="ruby-identifier">_completed_dirs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">parse_dir</span>(<span class="ruby-node">&quot;#{ _entry }/&quot;</span>, <span class="ruby-identifier">_cur_depth</span>))
                <span class="ruby-comment"># If current depth is less than limit (set in config), parse directory and pass depth</span>
                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">_cur_depth</span> <span class="ruby-operator">&lt;</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">parse_depth</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Depth less than max dept (from config), parsing directory\n&quot;</span>
                        <span class="ruby-identifier">_completed_dirs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">parse_dir</span>(<span class="ruby-node">&quot;#{ _entry }/&quot;</span>, <span class="ruby-identifier">_cur_depth</span>))
                <span class="ruby-comment"># Else, depth is greater than limit, ignore the directory</span>
                <span class="ruby-keyword">else</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Depth greater than max depth, ignoring\n&quot;</span>     
                <span class="ruby-keyword">end</span>

                <span class="ruby-comment"># Add directory to ignore list so it isn&#39;t repeated again accidentally</span>
                <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">ignore_list</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">_entry</span>)
        <span class="ruby-keyword">end</span>


        <span class="ruby-comment"># [review] - Not sure if Dir.glob requires a explicit directory/file close?</span>
                
        <span class="ruby-comment"># Create hash to hold all parsed files and directories</span>
        <span class="ruby-identifier">_structure</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-identifier">_structure</span>[<span class="ruby-value">:curdir</span>] = <span class="ruby-identifier">dir</span>
        <span class="ruby-identifier">_structure</span>[<span class="ruby-value">:files</span>] = <span class="ruby-identifier">_completed_files</span>
        <span class="ruby-identifier">_structure</span>[<span class="ruby-value">:subdirs</span>]  = <span class="ruby-identifier">_completed_dirs</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">_structure</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_dir-source -->
          
        </div>

        

        
      </div><!-- parse_dir-method -->

    
      <div id="method-i-parse_file" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_file</span><span
            class="method-args">(filename)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse through individual files looking for issue tags, then generate
formatted issue hash</p>
          
          

          
          <div class="method-source-code" id="parse_file-source">
            <pre><span class="ruby-comment"># File lib/watson/parser.rb, line 176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">parse_file</span>(<span class="ruby-identifier">filename</span>)
<span class="ruby-comment"># [review] - Rename method input param to filename (more verbose?)</span>

        <span class="ruby-comment"># Identify method entry</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ self } : #{ __method__ }\n&quot;</span>

        <span class="ruby-identifier">_relative_path</span> = <span class="ruby-identifier">filename</span>
        <span class="ruby-identifier">_absolute_path</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">absolute_path</span>(<span class="ruby-identifier">filename</span>) 

        <span class="ruby-comment"># Error check on input, use input filename to make sure relative path is correct</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-constant">Watson</span><span class="ruby-operator">::</span><span class="ruby-constant">FS</span>.<span class="ruby-identifier">check_file</span>(<span class="ruby-identifier">_relative_path</span>)
                <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;Unable to open #{ _relative_path }, exiting\n&quot;</span>
                <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
        <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Opened #{ _relative_path } for parsing\n&quot;</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Short path: #{ _relative_path }\n&quot;</span>
        <span class="ruby-keyword">end</span>


        <span class="ruby-comment"># Get filetype and set corresponding comment type</span>
        <span class="ruby-identifier">_comment_type</span> = <span class="ruby-identifier">get_comment_type</span>(<span class="ruby-identifier">_relative_path</span>)
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">_comment_type</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Using default (#) comment type\n&quot;</span>
                <span class="ruby-identifier">_comment_type</span> = <span class="ruby-node">&quot;#&quot;</span>
        <span class="ruby-keyword">end</span>


        <span class="ruby-comment"># Open file and read in entire thing into an array</span>
        <span class="ruby-comment"># Use an array so we can look ahead when creating issues later</span>
        <span class="ruby-comment"># [review] - Not sure if explicit file close is required here</span>
        <span class="ruby-comment"># [review] - Better var name than data for read in file?</span>
        <span class="ruby-identifier">_data</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">_absolute_path</span>, <span class="ruby-string">&#39;r&#39;</span>).<span class="ruby-identifier">read</span>.<span class="ruby-identifier">each_line</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_line</span> <span class="ruby-operator">|</span>
                <span class="ruby-identifier">_data</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">_line</span>)
        <span class="ruby-keyword">end</span>

        
        <span class="ruby-comment"># Initialize issue list hash </span>
        <span class="ruby-identifier">_issue_list</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-identifier">_issue_list</span>[<span class="ruby-value">:relative_path</span>] = <span class="ruby-identifier">_relative_path</span> 
        <span class="ruby-identifier">_issue_list</span>[<span class="ruby-value">:absolute_path</span>] = <span class="ruby-identifier">_absolute_path</span>
        <span class="ruby-identifier">_issue_list</span>[<span class="ruby-value">:has_issues</span>] = <span class="ruby-keyword">false</span>
        <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">tag_list</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_tag</span> <span class="ruby-operator">|</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Creating array named #{ _tag }\n&quot;</span>
                <span class="ruby-comment"># [review] - Use to_sym to make tag into symbol instead of string?</span>
                <span class="ruby-identifier">_issue_list</span>[<span class="ruby-identifier">_tag</span>] = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>
        <span class="ruby-keyword">end</span>
        
        <span class="ruby-comment"># Loop through all array elements (lines in file) and look for issues</span>
        <span class="ruby-identifier">_data</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_line</span>, <span class="ruby-identifier">_i</span> <span class="ruby-operator">|</span>

                <span class="ruby-comment"># Find any comment line with [tag] - text (any comb of space and # acceptable)</span>
                <span class="ruby-comment"># Using if match to stay consistent (with config.rb) see there for</span>
                <span class="ruby-comment"># explanation of why I do this (not a good good one persay...)</span>
                <span class="ruby-identifier">_mtch</span> = <span class="ruby-identifier">_line</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-string">&#39;UTF-8&#39;</span>, <span class="ruby-value">:invalid</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:replace</span>).<span class="ruby-identifier">match</span>(<span class="ruby-node">/^[#{ _comment_type }+?\s+?]+\[(\w+)\]\s+-\s+(.+)/</span>)
                <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">_mtch</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;No valid tag found in line, skipping\n&quot;</span>
                        <span class="ruby-keyword">next</span>
                <span class="ruby-keyword">end</span>
        
                <span class="ruby-comment"># Set tag</span>
                <span class="ruby-identifier">_tag</span> = <span class="ruby-identifier">_mtch</span>[<span class="ruby-value">1</span>]

                <span class="ruby-comment"># Make sure that the tag that was found is something we accept</span>
                <span class="ruby-comment"># If not, skip it but tell user about an unrecognized tag</span>
                <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@config</span>.<span class="ruby-identifier">tag_list</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">_tag</span>)
                        <span class="ruby-constant">Printer</span>.<span class="ruby-identifier">print_status</span> <span class="ruby-string">&quot;!&quot;</span>, <span class="ruby-constant">RED</span>
                        <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;Unknown tag [#{ _tag }] found, ignoring\n&quot;</span>
                        <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;      You might want to include it in your RC or with the -t/--tags flag\n&quot;</span>
                        <span class="ruby-keyword">next</span>
                <span class="ruby-keyword">end</span>

                <span class="ruby-comment"># Found a valid match (with recognized tag)</span>
                <span class="ruby-comment"># Set flag for this issue_list (for file) to indicate that</span>
                <span class="ruby-identifier">_issue_list</span>[<span class="ruby-value">:has_issues</span>] = <span class="ruby-keyword">true</span>

                <span class="ruby-identifier">_title</span> = <span class="ruby-identifier">_mtch</span>[<span class="ruby-value">2</span>]
                <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Issue found\n&quot;</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Tag: #{ _tag }\n&quot;</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Issue: #{ _title }\n&quot;</span>  

                <span class="ruby-comment"># Create hash for each issue found</span>
                <span class="ruby-identifier">_issue</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:line_number</span>] = <span class="ruby-identifier">_i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:title</span>] = <span class="ruby-identifier">_title</span>

                <span class="ruby-comment"># Grab context of issue specified by Config param (+1 to include issue itself)</span>
                <span class="ruby-identifier">_context</span> = <span class="ruby-identifier">_data</span>[<span class="ruby-identifier">_i</span><span class="ruby-operator">..</span>(<span class="ruby-identifier">_i</span> <span class="ruby-operator">+</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">context_depth</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)]

                <span class="ruby-comment"># [review] - There has got to be a better way to do this... </span>
                <span class="ruby-comment"># Go through each line of context and determine indentation</span>
                <span class="ruby-comment"># Used to preserve indentation in post</span>
                <span class="ruby-identifier">_cut</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span> 
                <span class="ruby-identifier">_context</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_line</span> <span class="ruby-operator">|</span>
                        <span class="ruby-identifier">_max</span> = <span class="ruby-value">0</span>
                        <span class="ruby-comment"># Until we reach a non indent OR the line is empty, keep slicin&#39;</span>
                        <span class="ruby-keyword">until</span> <span class="ruby-operator">!</span><span class="ruby-identifier">_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp">/^( |\t|\n)/</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">_line</span>.<span class="ruby-identifier">empty?</span>
                                <span class="ruby-comment"># [fix] - Replace with inplace slice!</span>
                                <span class="ruby-identifier">_line</span> = <span class="ruby-identifier">_line</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>)
                                <span class="ruby-identifier">_max</span> = <span class="ruby-identifier">_max</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>

                                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;New line: #{ _line }\n&quot;</span>
                                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Max indent: #{ _max }\n&quot;</span>
                        <span class="ruby-keyword">end</span>
                        
                        <span class="ruby-comment"># Push max indent for current line to the _cut array </span>
                        <span class="ruby-identifier">_cut</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">_max</span>)    
                <span class="ruby-keyword">end</span> 
        
                <span class="ruby-comment"># Print old _context</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;\n\n Old Context \n&quot;</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-constant">PP</span>.<span class="ruby-identifier">pp</span>(<span class="ruby-identifier">_context</span>, <span class="ruby-string">&quot;&quot;</span>)
                <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;\n\n&quot;</span>

                <span class="ruby-comment"># Trim the context lines to be left aligned but maintain indentation</span>
                <span class="ruby-comment"># Then add a single \t to the beginning so the Markdown is pretty on GitHub/Bitbucket</span>
                <span class="ruby-identifier">_context</span>.<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span> <span class="ruby-identifier">_line</span> <span class="ruby-operator">|</span> <span class="ruby-node">&quot;\t#{ _line.slice(_cut.min .. -1) }&quot;</span> }
        
                <span class="ruby-comment"># Print new _context        </span>
                <span class="ruby-identifier">debug_print</span>(<span class="ruby-string">&quot;\n\n New Context \n&quot;</span>)
                <span class="ruby-identifier">debug_print</span> <span class="ruby-constant">PP</span>.<span class="ruby-identifier">pp</span>(<span class="ruby-identifier">_context</span>, <span class="ruby-string">&quot;&quot;</span>)
                <span class="ruby-identifier">debug_print</span>(<span class="ruby-string">&quot;\n\n&quot;</span>)

                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:context</span>] = <span class="ruby-identifier">_context</span>
                        
                <span class="ruby-comment"># These are accessible from _issue_list, but we pass individual issues</span>
                <span class="ruby-comment"># to the remote poster, so we need this here to reference them for GitHub/Bitbucket</span>
                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:tag</span>] = <span class="ruby-identifier">_tag</span>
                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:path</span>] = <span class="ruby-identifier">_relative_path</span> 

                <span class="ruby-comment"># Generate md5 hash for each specific issue (for bookkeeping)</span>
                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:md5</span>] = <span class="ruby-operator">::</span><span class="ruby-constant">Digest</span><span class="ruby-operator">::</span><span class="ruby-constant">MD5</span>.<span class="ruby-identifier">hexdigest</span>(<span class="ruby-node">&quot;#{ _tag }, #{ _relative_path }, #{ _title }&quot;</span>)
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ _issue }\n&quot;</span>


                <span class="ruby-comment"># [todo] - Figure out a way to queue up posts so user has a progress bar?</span>
                <span class="ruby-comment"># That way user can tell that wait is because of http calls not app</span>
        
                <span class="ruby-comment"># If GitHub is valid, pass _issue to GitHub poster function</span>
                <span class="ruby-comment"># [review] - Keep Remote as a static method and pass config every time?</span>
                <span class="ruby-comment">#                    Or convert to a regular class and make an instance with @config</span>

                        <span class="ruby-keyword">if</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">remote_valid</span>
                                <span class="ruby-keyword">if</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">github_valid</span>
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;GitHub is valid, posting issue\n&quot;</span>
                                        <span class="ruby-constant">Remote</span><span class="ruby-operator">::</span><span class="ruby-constant">GitHub</span>.<span class="ruby-identifier">post_issue</span>(<span class="ruby-identifier">_issue</span>, <span class="ruby-ivar">@config</span>)
                                <span class="ruby-keyword">else</span>
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;GitHub invalid, not posting issue\n&quot;</span>
                                <span class="ruby-keyword">end</span>       


                                <span class="ruby-keyword">if</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">bitbucket_valid</span>
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Bitbucket is valid, posting issue\n&quot;</span>
                                        <span class="ruby-constant">Remote</span><span class="ruby-operator">::</span><span class="ruby-constant">Bitbucket</span>.<span class="ruby-identifier">post_issue</span>(<span class="ruby-identifier">_issue</span>, <span class="ruby-ivar">@config</span>)
                                <span class="ruby-keyword">else</span>
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Bitbucket invalid, not posting issue\n&quot;</span>
                                <span class="ruby-keyword">end</span>
                        <span class="ruby-keyword">end</span>
        
                        <span class="ruby-comment"># [review] - Use _tag string as symbol reference in hash or keep as string?</span>
                        <span class="ruby-comment"># Look into to_sym to keep format of all _issue params the same</span>
                        <span class="ruby-identifier">_issue_list</span>[<span class="ruby-identifier">_tag</span>].<span class="ruby-identifier">push</span>( <span class="ruby-identifier">_issue</span> )

        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># [review] - Return of parse_file is different than watson-perl</span>
        <span class="ruby-comment"># Not sure which makes more sense, ruby version seems simpler</span>
        <span class="ruby-comment"># perl version might have to stay since hash scoping is weird in perl</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;\nIssue list: #{ _issue_list }\n&quot;</span>

        <span class="ruby-keyword">return</span> <span class="ruby-identifier">_issue_list</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_file-source -->
          
        </div>

        

        
      </div><!-- parse_file-method -->

    
      <div id="method-i-run" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Begins parsing of files / dirs specified in the initial dir/file lists</p>
          
          

          
          <div class="method-source-code" id="run-source">
            <pre><span class="ruby-comment"># File lib/watson/parser.rb, line 32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">run</span>

        <span class="ruby-comment"># Identify method entry</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ self } : #{ __method__ }\n&quot;</span>
        
        <span class="ruby-comment"># Go through all files added from CL (sort them first)</span>
        <span class="ruby-comment"># If empty, sort and each will do nothing, no errors</span>
        <span class="ruby-identifier">_completed_dirs</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-identifier">_completed_files</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-keyword">if</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">cl_entry_set</span>
                <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">file_list</span>.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_file</span> <span class="ruby-operator">|</span>
                        <span class="ruby-identifier">_completed_files</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">parse_file</span>(<span class="ruby-identifier">_file</span>))
                <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
        
        <span class="ruby-comment"># Then go through all the specified directories </span>
        <span class="ruby-comment"># Initial parse depth to parse_dir is 0 (unlimited)</span>
        <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">dir_list</span>.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_dir</span> <span class="ruby-operator">|</span>
                <span class="ruby-identifier">_completed_dirs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">parse_dir</span>(<span class="ruby-identifier">_dir</span>, <span class="ruby-value">0</span>))
        <span class="ruby-keyword">end</span>  
        
        <span class="ruby-comment"># Create overall hash for parsed files       </span>
        <span class="ruby-identifier">_structure</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-identifier">_structure</span>[<span class="ruby-value">:files</span>] = <span class="ruby-identifier">_completed_files</span>
        <span class="ruby-identifier">_structure</span>[<span class="ruby-value">:subdirs</span>]  = <span class="ruby-identifier">_completed_dirs</span>

        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;_structure dump\n\n&quot;</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-constant">PP</span>.<span class="ruby-identifier">pp</span>(<span class="ruby-identifier">_structure</span>, <span class="ruby-string">&quot;&quot;</span>)
        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;\n\n&quot;</span>
        
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">_structure</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- run-source -->
          
        </div>

        

        
      </div><!-- run-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.1.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

