#!/usr/bin/perl
# watson - collaborative code tool
# Original Author: nhmood @ [goosecode labs] | 2012
# Contributor: eugenek @ [goosecode labs] | 2012
# Copyright (c) 2012-2013 goosecode labs
# See the file LICENSE for copying permission

# Todo:
# [!] - .watsonrc - hold config on what tags to search for
#  		take user command line arg
# [!] - put in pretty colors on terminal prompts/prints
# [!] - add Todo: listings as well as fixreviewme tags
# [!] - set tags through command line (only supports dirs now)
# [!] - add priority listing for tags and todo
# [!] - generate .html file with report
# [!] - add text editor/jump to code for each item in .html report
# [!] - feed output to less and change color prints 
# [!] - command line option to not create .watsonrc
# [!] - allow for single file usage instead of folder
# [!] - break everything into functions
# [!] - better error checking
# [!] - if x is placed in todo [!] then move it to separate file
# [!] - have option to export tags/todo to github/bitbucket issue tracker
# [!] - add function and ask user to send phonehome to keep track of stats
# [!] - add ability to generate error report(s)?
# 		turn on/off strict/warning and pipe (for perl for example)
# [!] - reformat how tag comments are defined
#		line on tag is short comment
#		all lines that are commented AFTER tag BEFORE newline are long comment
# [!] - changelist such that if a tag is replaced with its matching fixed
#		remove issue (resolve) on github/bitbucket, put it into list of fixed
#		issues, and modify source to remove tag (optional) 
# [!] - store in separate file or parse every time? (thinking parse)




# [reviewme] - Should I be using strict/warnings?
#use strict;
use warnings;

# For color print outs
#use Term::ANSIColor;

# For visualizing structures
use Data::Dumper;


# Global variables
my @DIRS;
my @TAGS;
my @STRUCTURE;
my $IGNORE_RC_DIRS = 0;


# Print watson header
# [reviewme] - clear might not be portable 
# Clear screen and set to top
print "\033[2J \033[0;0H";  


# Header info
print "watson - collaborative code tool \n";
print "nhmood @ [goosecode] 2012 \n\n";


# Open/create .watsonrc
print "[Checking for .watsonrc] \n";

# -z checks if filesize is 0
if ( -z ".watsonrc"){
	print ".watsonrc not found! \n";
	print "Creating default .watsonrc \n";

	# Create default .watsonrc
	createRC(".watsonrc");
}
else {
	print ".watsonrc found \n\n";
}


# Parse command line arguments
# Check args, only takes dirs for now
print "[Checking CL args]\n";
if ($#ARGV > -1){
	# Try to open each arg (as a directory)
	# If valid, push into @dirs array, else let user know
	foreach my $arg (@ARGV){
		if (checkDir($arg)){
			$arg =~ s/(\/)+$//;
			print "dirs: {$arg} valid directory, added from CL. \n";
			push(@DIRS, $arg);
			$IGNORE_RC_DIRS = 1;
			print "Ignoring RC directories\n";
		}
	}
	print "\n";
}
else {
	print "No command line arguments passed.\n";
	print "\n";

}


# Parse .watsonrc
print "Parsing .watsonrc\n";
open(my $watsonrc, "<", ".watsonrc");
# Read .watsonrc line by lin
my $section = "";
while (my $line = <$watsonrc>){
    print $line;
    # Ignore full line comments
    if ($line !~ m/^#/ && $line =~ /\S/){		
	# Regex to find [section], store into $section and continue to the next line until a new section
	if ($line =~ /^\[(\w+)\]/){
	    $section = $1;
	    next;
	}
      	# If @dirs wasn't populated by CL args, populate from .watsonrc
	if ($section eq "dirs"){
	    if ($IGNORE_RC_DIRS == 1) {
		print "Directories set from command line, ignoring .watsonrc [dirs]!\n";
	    }
	    else {
                # Specific regex for dirs, then push to @dirs
		$line =~ /^((\/?\w+\/?)+)/;
		$line = $1;
		$line =~ s/(\/)+$//;
		print "dirs: $line added from rc. \n";
		push(@DIRS, $line);
	    }
	}
	
	
	# Specific regex for tags, then push to @tags
	elsif ($section eq "tags"){
	    $line =~ /^(\w+( \| [0-9])?)/;
	    print "tags: $1 added from rc. \n";
	    push(@TAGS, $1);
	}
    } 
}

print "\n\n\n";




# For each directory obtained from .watsonrc or CL, look for files in them
foreach my $dir (@DIRS){
	push(@STRUCTURE, parseDirs($dir));
	#print Dumper(@structure);


        #print Dumper(parseDirs($dir)->{files}[0]);

        #if (parseDirs($dir) == 0){
        #        print "$dir could not be opened.\n";
        #}
}

<<<<<<< HEAD
#print Dumper(@STRUCTURE);
=======
#print Dumper(@structure);
>>>>>>> b640e1da60158cf1b27f5107bddeebf6826f52d5

# Display block
foreach my $entry (@STRUCTURE){
	printResults($entry);
}

sub printResults {
	my ($entry) = @_;
	for (my $i = 0; $i < scalar( @{$entry->{files}}); $i++){
		print $entry->{files}[$i]->{filename}, "\n";
		foreach my $tag (@TAGS){
			printf "\t\[$tag\]\n";
			for (my $j = 0; $j < scalar( @{$entry->{files}[$i]->{$tag}}); $j++){
				print "\t$entry->{files}[$i]->{$tag}[$j]->{linenumber} - ";
				print "$entry->{files}[$i]->{$tag}[$j]->{comment} \n";
			}
		}
	}

	for (my $i = 0; $i < scalar( @{$entry->{dirs}}); $i++){
		printResults($entry->{dirs}[$i]);
	}
}

sub parseFile {
	# [fixme] - need a better check for valid files (when using @_)
	my ($file) = @_;
	print "parseFile: $file\n";
	if (!length($file)){
		print "No file specified.\n";
		return 0;
	}

	my $fh = open(FILE, "<", $file);
	if (!$fh){
		printf "Could not open $file! \n";
		return 0;
	}

	# Go to beginning of the file
	seek(FILE, 0, 0);						 

	# Initialize tag arrays so they are globally avaliable
	foreach my $tag (@TAGS){
	    print "Creating array named $tag \n";
	    @{$tag};
	}

	# Read source file line by line
	my $linecount = 0;
	while (my $line = <FILE>){
	    $linecount++;
	    # Find any comment line with [tag] - text (any comb of space and #)
	    if ($line =~ /^#+\s*\[(\w+)\]\s*-\s*(.+)/) {
		print "Found an issue: $2\n";
		foreach my $tag (@TAGS) {
		    if ($1 eq $tag) {
			
			# Create hash for each issue found (for each tag)
			my $issue = {};
			$issue->{linenumber} = $linecount;
			$issue->{comment} = $2;
			push(@{$tag}, $issue);
		    }
		}
	    }
	}

	#[fixme] - change name to issueList
	my $issues = {};
<<<<<<< HEAD
=======
	$issues->{filename} = "$file"; 
	foreach $tag (@tags){
		$issues->{$tag} = [@{$tag}];
		#print Dumper($issues->{$tag}[0]);
		#print $issues->{filename}, "\n";
		undef @{$tag};
	}
>>>>>>> b640e1da60158cf1b27f5107bddeebf6826f52d5

	$issues->{filename} = "$file";
	# Toss on each tag found into the file's hash
	foreach my $tag (@TAGS){
	       	$issues->{$tag} = [@{$tag}];
		print Dumper($issues);
		undef @{$tag};       		
	}
	return $issues;
	
}


# Parse source files in specified directories for 
sub parseDirs {
	my ($dir) = @_;
	print "parseDirs: $dir\n";

	my @pdirs;
	my @pfiles;


	# [fixme] - Replace with global directory checker (exist + open)
	# Error check for input
	if (length($dir) == 0){
		print "No directories specified. \n";
		return 0;
	}

	# [fixme] - add option to stop from going deeper dirs (depth?)
	# Check if folder is valid and then read files in directory
	# If other folders are found, parse those as well
	# If file, pass through parseFile 
	
	# Error check directory
	opendir(my $pd, $dir);
	if (!$pd){
		print "$dir cannot be opened. \n";
		return -1;
	}
	print "$dir opened. \n";


	# [fixme] - get list in alphabetical order (looks better on output)
	# Loop through all entries in directory
	print "while loop starting. \n";
	my @dirlist = sort(readdir($pd));

	foreach my $entry (@dirlist){
		# Ignore . and ..
		if ($entry ne "." && $entry ne ".." && $entry ne ".git" && $entry ne ".gitignore"){
			# Check if entry is a file, if so parse
			if (-f "$dir/$entry"){
				print "$dir/$entry is a file!\n";
				push(@pfiles, parseFile("$dir/$entry"));
			}
			elsif (-d "$dir/$entry"){
				print "$dir/$entry is a dir!\n";
				push(@pdirs, parseDirs("$dir/$entry"));
			}
		}
	}

	closedir($pd);

	my $structure = {};
	$structure->{files} = \@pfiles;
	$structure->{dirs} = \@pdirs;

	return $structure;

}



# Functions


# checkDir - checks if directory exists
sub checkDir {
	my ($dir) = @_;
	# Error check for input
	if (length($dir) == 0){
		print "No directories specified.\n";
		return 0;
	}
	# Check if directory can be opened
	if (!opendir(DIR, $dir)){
		print "$dir is not a directory, skipping.\n";
		return -1;
	}
	return 1;
}


# printRC - creates default .watsonrc
sub createRC {
    my $file_name = shift;
    open(my $file, "+>>", ".watsonrc");
# [fixme] - Figure out a way to indent this?
my $rcdefault = <<EOF; 
# .watsonrc
# watson - collaborative code tool
# [goosecode] labs / 2012
\n
# Directories 
[dirs] 
src/
\n 
# Tags 
# tagname
# tagname - name of tag to look for (without []) 
[tags] 
fixme 
reviewme
EOF

    print $rcdefault;
	# Print default .watsonrc above to specified file
	print $file $rcdefault;
	return 1;
}

