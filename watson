#!/usr/bin/perl
# watson - inline issue manager
# Original Author: nhmood @ [goosecode labs] | 2012
# Contributor: eugenek @ [goosecode labs] | 2012
# Copyright (c) 2012-2013 goosecode labs
# See the file LICENSE for copying permission


# [todo] - command line arg for tags, ignore, createrc, other options
# [todo] - command line for file/folder (allow individual)
# [todo] - add priority listing for tags and todo
# [todo] - generate .html file with report
# [todo] - add text editor/jump to code for each item in .html report
# [todo] - if x is placed in todo [!] then move it to separate file
# [todo] - have option to export tags/todo to github/bitbucket issue tracker
# [todo] - add function and ask user to send phonehome to keep track of stats
# [todo] - changelist such that if a tag is replaced with its matching fixed
#		   remove issue (resolve) on github/bitbucket, put it into list of fixed
#		   issues, and modify source to remove tag (optional) 
# [todo] - store in separate file or parse every time? (thinking parse)
# [todo] - tell when directory changes with some header
# [todo] - support other comment types
# [todo] - change @IGNOREDIR to hash instead of array for efficiency
# [todo] - only allow user to check executing users files (setuid exploit)
# [todo] - allow single files in rc file (use different [files] section?)

###########################################################
# Global parameters 
###########################################################

# For testing
#use strict;
#use warnings;

# For color print outs
use Term::ANSIColor qw(:constants);

# For debugging (print data structures)
use Data::Dumper;

# App Config
my $DEBUG = 0;
my $RCNAME = ".watsonrc";		# Change config file name
my $TMPOUT = ".watsonresults";	# Change tmp file name

# Global variables
my @DIRS;
my @FILES;
my @TAGS;
my @IGNORE;
my @STRUCTURE;
my $MAX_DEPTH = 0;
my $DEPTH = 0;
my $IGNORE_RC_DIRS = 0;
my $IGNORE_RC_FILES = 0;
my $IGNORE_RC_TAGS = 0;
my $IGNORE_RC_IGNORE = 0;
my $HASLESS = 0;
my $LESSOUT;


#----------------------------------------------------------
###########################################################
# Main Program 
###########################################################
#----------------------------------------------------------

checkLess();
printHeader();
parseCommandLine();
checkConfig();
parseConfig();
startScan();
createReport();


#----------------------------------------------------------
###########################################################
# Functions 
###########################################################
#----------------------------------------------------------


###########################################################
# Header Print 
###########################################################

# Print watson header
sub printHeader {
	wprint(BOLD "---------------------------\n");
	wprint(BOLD "watson", RESET);
	wprint(" - ");
	wprint(BOLD YELLOW "code review tool\n", RESET);
	wprint(BOLD "---------------------------\n\n");
	return 1;
}


###########################################################
# Help Print 
###########################################################

# Print watson help 
sub printHelp {

	print "Usage: watson [OPTION]...\n";
	print "Running watson with no arguments will parse with settings in RC file\n";
	print "If no RC file exists, default RC file will be created\n";

	print "\n";
	print "   -d, --dirs			list of directories to search in\n";
	print "   -f, --files			list of files to search in\n";
	print "   -h, --help			print help\n";
	print "   -i, --ignore			list of files, directories, or filetypes (*.type) to ignore\n";
	print "   -m, --max-depth		specify max depth for recursive directory parsing\n";
	print "   -t, --tags			list of tags to search for\n";
	print "   -v, --version		print watson version and info\n";
	print "\n";

	print "Any number of files, tags, dirs, and ignores can be listed after flag\n";
	print "To use *.filetype identifier, encapsulate in \"\" to avoid shell substitutions \n";
	print "\n";

	print "Report bugs to: watson\@goosecode.com\n";
	print "watson home page: <http://goosecode.com/projects/watson>\n";
	print "[goosecode] labs | 2012-2013\n";

	return 1;
}


###########################################################
# Help Print 
###########################################################

# Print watson help 
sub printVersion {

	print "watson v1.1\n";
	print "Copyright (c) 2012-2013 goosecode labs\n";
	print "Licensed under MIT, see LICENSE for details\n";
	print "\n";

	print "Written by nhmood and others, see <http://goosecode.com/projects/watson>\n";
	return 1;
}


###########################################################
# Debug Print
###########################################################

# Debug print statements that are only enabled
# when debug flag is set (top of file)
sub debugPrint {
	if ($DEBUG){
		print @_;
	}
	return 1;
}


###########################################################
# Output Print
###########################################################

# If system has less, dump all output to .tmp file and use less
# If no less, just print straight to stdout
sub wprint {
	my ($line) = @_;
	
	if ($HASLESS){
		print $LESSOUT "$line";
		return 1;
	}
	else {
		print "$line";
		return 0;
	}
}


###########################################################
# Unix less Checker
###########################################################

# Check to see if system has less
# If so, set flag and open tmp file
sub checkLess {
	if (! system("which less > /dev/null 2>&1") ){
		open($LESSOUT, "+>", $TMPOUT);
		$HASLESS = 1;
		return 1;
	}
	else {
		return 0;
	}
}


###########################################################
# Directory checker  
###########################################################

# checkDir - checks if directory can be opened 
# Different from just using -d, checks if able to OPEN
sub checkDir {
	my ($dir) = @_;
	# Error check for input
	if (length($dir) == 0){
		wprint("No directories specified.\n");
		return 0;
	}
	# Check if directory can be opened
	my $success = opendir(my $tDIR, $dir);
	if (!$success){
		wprint("Cannot open dir: |$dir|, skipping.\n");
		return 0;
	}

	closedir($tDIR);
	debugPrint("|$dir| exists and opened successfully.\n");
	return 1;
}


###########################################################
# File checker  
###########################################################

# checkFile - checks if file can be opened
# Different from just using -f, checks if able to OPEN
sub checkFile {
	my ($file) = @_;
	# Error check for input
	if (length($file) == 0){
		wprint("No file specified.\n");
		return 0;
	}

	# Check if file can be opened
	my $success = open(my $tFILE, $file);
	if (!$success){
		wprint("Could not open |$file|, skipping.\n");
		return 0;
	}

	close($tFILE);
	debugPrint("|$file| exists and opened successfully.\n");
	return 1;
}


###########################################################
# Config file check
###########################################################

# Check for config file in same dir as watson
# If it doesn't exist, create the default one
sub checkConfig {
	# Should have individual .rc for each dir that watson is in
	# This allows you to keep different preferences for different projects
	
	# Check for rc
	# -z checks if filesize is 0
	debugPrint("[Checking for $RCNAME] \n");
	if (! -e "$RCNAME"){
		debugPrint("$RCNAME not found! \n");
		debugPrint("Creating default $RCNAME \n");
	
		# Create default rc
		createRC("$RCNAME");
		return 0;
	}
	else {
		debugPrint("$RCNAME found \n\n");
		return 1;
	}
}


###########################################################
# Default config file writer 
###########################################################

# Create default RC file with some generic settings
sub createRC {
	my $file_name = shift;
	open(my $file, "+>>", "$RCNAME");
# [fixme] - Figure out a way to indent this?
my $rcdefault = <<EOF; 
# watson rc
# watson - inline issue manager
# [goosecode] labs / 2012
\n
# Directories 
[dirs] 
./
\n 
# Tags 
[tags] 
fixme 
reviewme
todo
\n
[ignore]
.git
EOF

	debugPrint($rcdefault);
	# Print default rc above to specified file
	# [fixme] - Get return 
	my $success = print $file $rcdefault;
	close($file);
	return $success;
}


###########################################################
# Command line parser 
###########################################################

# Parse command line arguments
sub parseCommandLine {
	debugPrint("[Checking CL args]\n");
	debugPrint("Total args: ", $#ARGV + 1, "\n");

	my @opts = ("-d", "--dirs", 
				"-f", "--files",
				"-h", "--help", 
				"-t", "--tags",
				"-m", "--max-depth",
				"-i", "--ignore"); 


	# Check number of command lines, skip if invalid
	if ($#ARGV > -1){
		for (my $i = 0; $i < $#ARGV + 1; $i++){
			debugPrint("Main Index: $i: $ARGV[$i]\n");		
		
			if ($ARGV[$i] eq "-h" || $ARGV[$i] eq "--help"){
				debugPrint("Help flag passed\n");
				printHelp();		
				exit 0;
			}

			if ($ARGV[$i] eq "-v" || $ARGV[$i] eq "--version"){
				debugPrint("Version flag passed\n");
				printVersion();
				exit 0;
			}
	
			if ($ARGV[$i] eq "-m" || $ARGV[$i] eq "--max-depth"){
				debugPrint("Max Depth flag passed\n");
				# Check to make sure next param is a valid number (non-negative)
				if ( $ARGV[$i + 1] =~ m/^([0-9]+)$/ ){
					$MAX_DEPTH = $ARGV[$i + 1];
					debugPrint("Valid max depth: $MAX_DEPTH\n");
				}
				else {
					wprint(BOLD "[ ", RESET);
					wprint(BOLD MAGENTA "! ", RESET);
					wprint(BOLD "] ", RESET);
					wprint("--> ", RESET);
					wprint("Invalid max depth passed\n");
				}
				
				# Move index to two after (flag and value)
				$i = $i + 2;

			}


			if ($ARGV[$i] eq "-d" || $ARGV[$i] eq "--dirs"){
				debugPrint("Dir flag passed\n");
				# Keep track of number of args for when we exit loop
				my $count = 0;

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
		
						debugPrint("Dir Index: $j: $ARGV[$j]\n");
						$count++;	
						if (checkDir($ARGV[$j])){
	
							debugPrint("dirflag: {$ARGV[$j]} valid directory, added from CL.\n");
	
							# If we ever get into this, means CL passed
							# Set RC ignore so we don't look at rc
							debugPrint("Ignoring RC Files/Dirs\n\n");
							$IGNORE_RC_DIRS = 1;
	
							# Remove trailing slashes
							$ARGV[$j] =~ s/(\/)+$//;
							push(@DIRS, $ARGV[$j]);
						}
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
				
			}
		

			if ($ARGV[$i] eq "-f" || $ARGV[$i] eq "--files"){
				debugPrint("File flag passed\n");
				# Keep track of number of args for when we exit loop
				my $count = 0;	

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
			
						debugPrint("File Index: $j: $ARGV[$j]\n");
						$count++;	
						if (checkFile($ARGV[$j])){
					
							debugPrint("fileflag: {$ARGV[$j]} valid file, added from CL.\n");	
	
							# If we ever get into this, means CL passed
							# Set RC ignore so we don't look at rc
							debugPrint("Ignoring RC Files/Dirs\n\n");
							$IGNORE_RC_FILES = 1;
	
							push(@FILES, $ARGV[$j]);
						}
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
			}
	
	
			if ($ARGV[$i] eq "-t" || $ARGV[$i] eq "--tags"){
				debugPrint("Tag flag passed\n");
				# Keep track of number of args for when we exit loop
				my $count = 0;

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
					
						debugPrint("Tag Index: $j: $ARGV[$j]\n");
						$count++;	
						
						debugPrint("tagflag: {$ARGV[$j]} added from CL.\n");	
	
						# If we ever get into this, means CL passed
						# Set RC ignore so we don't look at rc
						debugPrint("Ignoring RC tags\n\n");
						$IGNORE_RC_TAGS = 1;
	
						push(@TAGS, $ARGV[$j]);
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
			}
	

			if ($ARGV[$i] eq "-i" || $ARGV[$i] eq "--ignore"){
				debugPrint("Ignore flag passed\n");
				# Keep track of number of args for when we exit loop				
				my $count = 0;

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
					
						debugPrint("Ignore Index: $j: $ARGV[$j]\n");
						$count++;	
						
						debugPrint("ignoreflag: {$ARGV[$j]} added from CL.\n");	
	
						# If we ever get into this, means CL passed
						# Set RC ignore so we don't look at rc
						debugPrint("Ignoring RC ignore\n\n");
						$IGNORE_RC_IGNORE = 1;
	
						push(@IGNORE, $ARGV[$j]);
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
			}
		}
	}
	else {
		debugPrint("No command line arguments passed.\n\n");	
	}
	return 1;
}


###########################################################
# Config file parser
###########################################################

# Go through config file and determine dirs, tags, and ignores to use
sub parseConfig {
	# Parse rc
	debugPrint("Parsing $RCNAME\n");
	
	open(my $rc, "<", "$RCNAME");
	
	# Add . and .. and .git to ignorelist 
	push(@IGNORE, ".");
	push(@IGNORE, "..");
	push(@IGNORE, "*.swp");
	push(@IGNORE, $TMPOUT);
	
	
	# Read rc line by line
	my $section = "";
	while (my $line = <$rc>){
	    debugPrint($line);
	    
		# Ignore full line comments
	    if ($line !~ m/^#/ && $line =~ /\S/){
			# Regex to find [section], store into $section and continue to the
			# next line until a new section
			if ($line =~ /^\[(\w+)\]/){
			    $section = $1;
			    next;
			}
	    	
			# If @DIRS or @FILES wasn't populated by CL args, populate from rc
			if ($section eq "dirs"){
			    if ($IGNORE_RC_DIRS == 1 || $IGNORE_RC_FILES == 1) {
					debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
			    }
			    else {
	    	        # Regex for dirs, then push to @DIRS
					$line =~ /^((\.?\/?\w?+\/?)+)/;
					$line = $1;
					$line =~ s/(\/)+$//;
					debugPrint("dirs: $line added from rc. \n");
					push(@DIRS, $line);
			    }
			}
			
			# If @TAGS wasn't populated by CL args, populate from rc
			elsif ($section eq "tags"){
			    if ($IGNORE_RC_TAGS == 1) {
					debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
			    }
				else {
					# Regex for tags, then push to @TAGS
			    	$line =~ /^(\w+( \| [0-9])?)/;
			    	debugPrint("tags: $1 added from rc. \n");
			    	push(@TAGS, $1);
				}
			}
	
			# If @IGNORE wasn't populated by CL args, populate from rc
			elsif ($section eq "ignore"){
			    if ($IGNORE_RC_IGNORE == 1) {
					debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
			    }
				else {
					# Regex for dirs to ignore, then push to @IGNOREDIR

					$line =~ /^((\/?\w+\/?)+)/;
					$line = $1;
					$line =~ s/(\/)+$//;
					debugPrint("ignore: $line added from rc.\n");
					push(@IGNORE, $line);
				}
			}
	    } 
	}

	debugPrint("\n\n\n");
	close($rc);
	return 1;
}	


###########################################################
# File/Folder Parser Wrapper
###########################################################

# Start going through all files and subdirs of specified folder
sub startScan{
	
	# If files passed to command line, push those to structure
	# Have to populate structure this way to print properly
	if ($IGNORE_RC_FILES){
		# For each file obtained from CL (if any) parse file
		# Create proper structure for files so we can push to @STRUCTURE
		my $structure = {};
		my @tfiles = ();
		foreach my $file (@FILES){
			push(@tfiles, parseFile($file));
		}
		
		$structure->{files} = \@tfiles;
		push(@STRUCTURE, $structure);
	}

	# For each directory obtained from rc or CL, look for files in them
	# This will always be valid, not condition like files above
	foreach my $dir (@DIRS){
		push(@STRUCTURE, parseDirs($dir));
		# Reset DEPTH on directories specified (not dirs found within)
		$DEPTH = 0;
	}

	wprint("\n");
	return 1;
}


###########################################################
# Directory Parser
###########################################################

# Look through directory for files to parse
sub parseDirs {
	my ($dir) = @_;
	debugPrint("parseDirs: |$dir|\n");

	my @pdirs;		# subdirectories found
	my @pfiles;		# files found

	

	# Error check for input
	if (!checkDir($dir)){
		return 0;
	}
	
	# [fixme] - add option to stop from going deeper dirs (depth?)
	# Loop through all entries in directory
	debugPrint("Looping through all files/folders in |$dir|\n");

	# Open dir and get list of all files	
	opendir(my $wd, $dir);
	my @dirlist = sort(readdir($wd));

	foreach my $entry (@dirlist){
		# Create singular $path var to parse
		# Remove trailing slashes
		$dir =~ s/^(\/)+$//;
		
		# Combine dir and entry to make full path
		my $path = "$dir/$entry";

		# Remove leading ., /, or ./
		$path =~ s/^((\.)?(\/)?)//; 

		debugPrint("path: |$path|\n");

		# Make sure it isn't part of ignored list
		# If it is, set to "", won't pass dir/file check
		# [reviewme] - Should we warn users when file is ignored on stdout?
		foreach my $ignore (@IGNORE){
			# Check for any *.type in ignore list (list .swp)
			# Regex to see if extension is .type, ignore if so 
			if ( substr($ignore, 0, 1) eq "*" ){
				my $ignoretype = substr($ignore, 1);
				if ( $entry =~ m/$ignoretype$/ ){
					debugPrint("|$path| is on the ignore list, setting to nothing\n");
					$path = "";
				}
			}
			elsif ("$entry" eq "$ignore" | "$path" eq "$ignore"){
				debugPrint("|$path| is on the ignore list, setting to nothing\n");
				$path = "";
				last;
			}
		}
		
		# Check if entry is a file, if so parse
		if (-f "$path"){
			debugPrint("|$path| is a file!\n");
			push(@pfiles, parseFile("$path"));
		}

		# Check if entry is dir, if so parse
		elsif (-d "$path"){
			debugPrint("|$path| is a dir!\n");

			# If MAX_DEPTH is 0, no limit on subdirs
			# Increment DEPTH, compare with MAX_DEPTH
			# If less than depth, parse dir, else ignore
			$DEPTH++;
			debugPrint("Folder depth: $DEPTH\n");
			if ($MAX_DEPTH == 0){
				debugPrint("No max depth, parsing folders\n");
				push(@pdirs, parseDirs("$path"));
			}
			elsif ($DEPTH < $MAX_DEPTH){
				debugPrint("Depth less than Max depth, parsing folder\n");
				push(@pdirs, parseDirs("$path"));
			}
			else {
				debugPrint("Depth greater than Max depth, ignoring\n");
			}

		}

		# Add directory to ignore list so it isn't repeated again
		push(@IGNORE, $path);
		
	}

	closedir($wd);
	# Create has to hold all parsed files and folders
	my $structure = {};

	# Still confused as to what this is actually doing but...
	# Storing an array of hashes into structure->file hash
	# I THINK?? that because the array consists of hashes (references)
	# the \@pfiles will copy the actual values (or keep the references alive?)
	# Either way, some scoping thing is solved with \@
	
	$structure->{files} = \@pfiles;
	$structure->{dirs} = \@pdirs;

	return $structure;
}


###########################################################
# File Parser
###########################################################

sub parseFile {
	# [fixme] - need a better check for valid files (when using @_)
	my ($file) = @_;
	debugPrint("parseFile: |$file|\n");

	# Error check for input
	if (!checkFile($file)){
		return 0;
	}

	# Get filetype and set corresponding comment type
	my $comment = getComment($file);
	if (!$comment){
		wprint(BOLD "[ ", RESET);
		wprint(BOLD MAGENTA "! ", RESET);
		wprint(BOLD "] ", RESET);
		wprint("--> ", RESET);
		wprint("Couldn't determine filetype for $file, using # as comment\n", RESET);
		$comment = "#";
	}

	# Open file and seek to beginning
	open(my $wf, "<", $file);
	seek($wf, 0, 0);						 

	# Initialize tag arrays so they are globally avaliable
	foreach my $tag (@TAGS){
	    debugPrint("Creating array named $tag \n");
	    @{$tag};
	}

	# Read source file line by line
	my $linecount = 0;
	while (my $line = <$wf>){
	    $linecount++;
	    # Find any comment line with [tag] - text (any comb of space and #)
	    if ($line =~ /\s*($comment)+\s*\[(\S+)\]\s*-\s*(.+)/) {
			my $fissue = $3;
			my $ftag = $2;
			debugPrint("Issue found!\n");
			debugPrint("Tag: $ftag\n");		
			debugPrint("Issue: $fissue\n");
		
			foreach my $tag (@TAGS) {
		    	if ($ftag eq $tag) {
					# Create hash for each issue found (for each tag)
					my $issue = {};
					$issue->{linenumber} = $linecount;
					$issue->{comment} = $fissue;
					push(@{$tag}, $issue);
		    	}
			}
	    }
	}

	#[fixme] - change name to issueList
	my $issueList = {};
	$issueList->{filename} = "$file";
	
	# Toss on each tag found into the file's hash
	foreach my $tag (@TAGS){
	       	$issueList->{$tag} = [@{$tag}];
		debugPrint(Dumper($issueList));
		undef @{$tag};       		
	}
	return $issueList;
}


###########################################################
# Comment setter
###########################################################

# Determine comment type from file extension
sub getComment {
	my ($file) = @_;
	debugPrint("Getting comment type\n");

	# Grab the ending extension (.something)
	# Check to see whether it is recognized and set comment type
	# If unrecognized, try to grab next .something extension
	# This is to account for file.cpp.1 or file.cpp.bak, ect
	
	while ( (my $ext) = $file =~ m/(\.(\w+))$/){
		# Regex for last extension
		debugPrint("Extension: $ext\n");

		# Determine file type
		# Not using switch/case for compatibility...
		
		# C / C++
		# [todo] - add /* style comment
		if ( $ext eq ".cpp" || $ext eq ".cc" ||  $ext eq ".c" || $ext eq ".h"){
			debugPrint("Comment type is: //\n");
			return "//";
		}
		# Bash / Ruby / Perl	
		elsif ( $ext eq ".sh" || $ext eq ".rb" || $ext eq ".pl"){
			debugPrint("Comment type is: #\n");
			return "#";
		}
		# Can't recognize extension, keep looping
		else {
			$file =~ s/(\.(\w+))$//;
			debugPrint("Didn't recognize, new file: $file\n");
		}
	}
	
	# Didn't find any match, return error (and just use #)
	return 0;
}


###########################################################
# Result Printer Wrapper
###########################################################

# Format the parsed file data and output it nicely
sub createReport {
	# Display output for each file parsed 
	foreach my $entry (@STRUCTURE){
		printResults($entry);
	}
	
	if ($HASLESS){
		system("less $TMPOUT");
		close($LESSOUT);
		system("rm $TMPOUT > /dev/null 2>&1");
	}
	return 1;
}


###########################################################
# Individual Result Printer
###########################################################

# Print results from parsing all pretty and stuff
sub printResults {
	my ($entry) = @_;
	# Go through and print info for all files first
	for (my $i = 0; $i < scalar( @{$entry->{files}}); $i++){

		# [fixme] - Same foreach performed below, combine somehow?

		# Go through and see if there are any issues with given file
		# Sets print color and whether to continue to print
		my $issueflag = 0; 
		foreach my $tag (@TAGS){
			if (scalar( @{$entry->{files}[$i]->{$tag}})){
				$issueflag++;
			}
		}
		
		if ($issueflag){
			wprint("\n");
			wprint(BOLD "[ ", RESET);
			wprint(BOLD RED "x ", RESET);
			wprint(BOLD "] ", RESET);
			wprint(UNDERLINE BOLD RED "$entry->{files}[$i]->{filename}", RESET);
		}
		else {
			wprint(BOLD "[ ", RESET);
			wprint(BOLD GREEN "o ", RESET);
			wprint(BOLD "] ", RESET);
			wprint(UNDERLINE BOLD GREEN "$entry->{files}[$i]->{filename}", RESET);
		}

		wprint("\n");
		
		# If there are no issues, don't print anything (go to next file)
		# Else, continue on and print the issues
		($issueflag > 0) ? (1) : (next);	

		# Cycle through all tags and print issues for each	
		foreach my $tag (@TAGS){
		
			# If no issues in tag, don't print	
			if (!scalar( @{$entry->{files}[$i]->{$tag}})){
				next;
			}
		
			# Print tag, line #, and issue	
			wprint(BOLD  "\[ ", RESET);
			wprint(BOLD BLUE "$tag", RESET);
			wprint(BOLD  " \]\n", RESET);

			for (my $j = 0; $j < scalar( @{$entry->{files}[$i]->{$tag}}); $j++){
				wprint(WHITE "  line $entry->{files}[$i]->{$tag}[$j]->{linenumber} - ", RESET);
				wprint(BOLD "$entry->{files}[$i]->{$tag}[$j]->{comment} \n", RESET); 
			}
			wprint("\n");
		}
	}

	for (my $i = 0; $i < scalar( @{$entry->{dirs}}); $i++){
		printResults($entry->{dirs}[$i]);
	}
	return 1;
}
