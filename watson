#!/usr/bin/perl
# watson - collaborative code tool
# nhmood @ [goosecode labs] | 2012
# Copyright (c) 2012-2013 goosecode labs
# See the file LICENSE for copying permission

# Todo:
# [!] - .watsonrc - hold config on what tags to search for
#  		take user command line arg
# [!] - put in pretty colors on terminal prompts/prints
# [!] - add Todo: listings as well as fixreviewme tags
# [!] - set tags through command line (only supports dirs now)
# [!] - add priority listing for tags and todo
# [!] - generate .html file with report
# [!] - add text editor/jump to code for each item in .html report
# [!] - feed output to less and change color prints 
# [!] - command line option to not create .watsonrc
# [!] - allow for single file usage instead of folder
# [!] - break everything into functions
# [!] - better error checking
# [!] - if x is placed in todo [!] then move it to separate file
# [!] - have option to export tags/todo to github/bitbucket issue tracker
# [!] - add function and ask user to send phonehome to keep track of stats
# [!] - add ability to generate error report(s)?
# 		turn on/off strict/warning and pipe (for perl for example)
# [!] - reformat how tag comments are defined
#		line on tag is short comment
#		all lines that are commented AFTER tag BEFORE newline are long comment
# [!] - changelist such that if a tag is replaced with its matching fixed
#		remove issue (resolve) on github/bitbucket, put it into list of fixed
#		issues, and modify source to remove tag (optional) 
# [!] - store in separate file or parse every time? (thinking parse)




# [reviewme] - Should I be using strict/warnings?
#use strict;
use warnings;
# For color print outs
#use Term::ANSIColor;

# For visualizing structures
use Data::Dumper;



# Global variables
my @dirs;
my @tags;
my @structure;
	


# Print watson header
# [reviewme] - clear might not be portable 
# Clear screen and set to top
print "\033[2J \033[0;0H";  


# Header info
print "watson - collaborative code tool \n";
print "nhmood @ [goosecode] 2012 \n\n";


# Open/create .watsonrc
print "[Checking for .watsonrc] \n";
# [reviewme] - Allow user to set name of file?
open(RC, "+>>", ".watsonrc");
# -z checks if filesize is 0
if ( -z ".watsonrc"){
	print ".watsonrc not found! \n";
	print "Creating default .watsonrc \n";

	# Create default .watsonrc
	createRC(RC);
}
else {
	print ".watsonrc found \n\n";
}


# Parse command line arguments
# Check args, only takes dirs for now
print "[Checking CL args]\n";
if ($#ARGV > -1){
	# Try to open each arg (as a directory)
	# If valid, push into @dirs array, else let user know
	foreach my $arg (@ARGV){
		if (checkDir($arg)){
			$arg =~ s/(\/)+$//;
			print "dirs: {$arg} valid directory, added from CL. \n";
			push(@dirs, $arg);
		}
	}
	print "\n";
}
else {
	print "No command line arguments passed.\n";
	print "\n";

}


# Parse .watsonrc
print "Parsing .watsonrc\n";

# Go to beginning of file
seek(RC, 0, 0);						 

# Read .watsonrc line by line
while (my $line = <RC>){

	# Ignore full line comments
	if ($line !~ m/^#/){		
		# Regex to find [section], store into $section
		if ($line =~ /^\[(\w+)\]/){
			# [fixme] - strict says I need to scope $section, but can't get it to work
			$section = $1;
			
			
			# [reviewme] - Seems like theres a better way to "unset" $section
			# If @dirs wasn't populated by CL args, populate from .watsonrc
			if ($section eq 'dirs' && scalar(@dirs) != 0){
				print "Directories set from command line, ignoring .watsonrc [dirs]!\n";
				$section = '';
			}
		}

		# Else, if not a blank line, valid parameter
		# Store into array of whichever section last defined
		elsif ($section ne '' && ($line =~ /\S/)){
			# Specific regex for dirs, then push to @dirs
			if ($section eq "dirs"){
				
				$line =~ /^((\/?\w+\/?)+)/;
				$line = $1;
				$line =~ s/(\/)+$//;
				print "dirs: $line added from rc. \n";

				push(@dirs, $line);
			}
			# Specific regex for tags, then push to @tags
			elsif ($section eq "tags"){
				$line =~ /^(\w+( \| [0-9])?)/;
				print "tags: {$1} added from rc. \n";
				push(@tags, $1);
			}
		} 

	}
}
print "\n\n\n";




# For each directory obtained from .watsonrc or CL, look for files in them
foreach my $dir (@dirs){
	push(@structure, parseDirs($dir));
	#print Dumper(@structure);


        #print Dumper(parseDirs($dir)->{files}[0]);

        #if (parseDirs($dir) == 0){
        #        print "$dir could not be opened.\n";
        #}
}

print Dumper(@structure);

# Display block
foreach $entry (@structure){
	printResults($entry);
}

sub printResults {
	my ($entry) = @_;
	for ($i = 0; $i < scalar( @{$entry->{files}}); $i++){
		print $entry->{files}[$i]->{filename}, "\n";
		foreach $tag (@tags){
			printf "\t\[$tag\]\n";
			for ($j = 0; $j < scalar( @{$entry->{files}[$i]->{$tag}}); $j++){
				print "\t$entry->{files}[$i]->{$tag}[$j]->{linenumber} - ";
				print "$entry->{files}[$i]->{$tag}[$j]->{comment} \n";
			}
		}
	}

	for ($i = 0; $i < scalar( @{$entry->{dirs}}); $i++){
		printResults($entry->{dirs}[$i]);
	}
}

sub parseFile {
	# [fixme] - need a better check for valid files (when using @_)
	my ($file) = @_;
	print "parseFile: $file\n";
	if (!length($file)){
		print "No file specified.\n";
		return 0;
	}

	my $fh = open(FILE, "<", $file);
	if (!$fh){
		printf "Could not open $file! \n";
		return 0;
	}

	# Go to beginning of the file
	seek(FILE, 0, 0);						 

	# Initialize tag arrays so they are globally avaliable
	foreach $tag (@tags){
		@{$tag};
	}

	# Read source file line by line
	my $linecount = 0;
	while (my $line = <FILE>){
		$linecount++;
		# Find any comment line with [tag] - text (any comb of space and #)
		if ($line =~ /^#+\s*\[(\w+)\]\s*-\s*(.+)/){
			foreach my $tag (@tags){
				if ($1 eq $tag){
					
					# Create hash for each issue found (for each tag)
					$issue = {};
					$issue->{linenumber} = $linecount;
					$issue->{comment} = $2;
					push(@{$tag}, $issue);
				}
			}
		}
	}

	#[fixme] - change name to issueList
	my $issues = {};
	$issues->{filename} = "$file"; 
	foreach $tag (@tags){
		$issues->{$tag} = \@{$tag};
		#print Dumper($issues->{$tag}[0]);
		#print $issues->{filename}, "\n";
	}

	return $issues;
	
}


# Parse source files in specified directories for 
sub parseDirs {
	my ($dir) = @_;
	print "parseDirs: $dir\n";

	my @pdirs;
	my @pfiles;


	# [fixme] - Replace with global directory checker (exist + open)
	# Error check for input
	if (length($dir) == 0){
		print "No directories specified. \n";
		return 0;
	}

	# [fixme] - add option to stop from going deeper dirs (depth?)
	# Check if folder is valid and then read files in directory
	# If other folders are found, parse those as well
	# If file, pass through parseFile 
	
	# Error check directory
	opendir(my $pd, $dir);
	if (!$pd){
		print "$dir cannot be opened. \n";
		return -1;
	}
	print "$dir opened. \n";


	# [fixme] - get list in alphabetical order (looks better on output)
	# Loop through all entries in directory
	print "while loop starting. \n";
	my @dirlist = sort(readdir($pd));

	foreach $entry (@dirlist){
		# Ignore . and ..
		if ($entry ne "." && $entry ne ".." && $entry ne ".git" && $entry ne ".gitignore"){
			# Check if entry is a file, if so parse
			if (-f "$dir/$entry"){
				print "$dir/$entry is a file!\n";
				push(@pfiles, parseFile("$dir/$entry"));
			}
			elsif (-d "$dir/$entry"){
				print "$dir/$entry is a dir!\n";
				push(@pdirs, parseDirs("$dir/$entry"));
			}
		}
	}

	closedir($pd);

	$structure = {};
	$structure->{files} = \@pfiles;
	$structure->{dirs} = \@pdirs;

	return $structure;

}



# Functions


# checkDir - checks if directory exists
sub checkDir {
	my ($dir) = @_;
	# Error check for input
	if (length($dir) == 0){
		print "No directories specified.\n";
		return 0;
	}
	# Check if directory can be opened
	if (!opendir(DIR, $dir)){
		print "$dir is not a directory, skipping.\n";
		return -1;
	}
	return 1;
}


# printRC - creates default .watsonrc
sub createRC {
	my ($file) = @_;

# [fixme] - Figure out a way to indent this?
my $rcdefault = <<EOF; 
# .watsonrc
# watson - collaborative code tool
# [goosecode] labs / 2012
\n
# Directories 
[dirs] 
src/
\n 
# Tags 
# tagname
# tagname - name of tag to look for (without []) 
[tags] 
fixme 
reviewme
EOF

	# Print default .watsonrc above to specified file
	print $file $rcdefault;
	return 1;
}

