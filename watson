#!/usr/bin/perl
# watson - inline issue manager
# Original Author: nhmood @ [goosecode labs] | 2012
# Contributor: eugenek @ [goosecode labs] | 2012
# Copyright (c) 2012-2013 goosecode labs
# See the file LICENSE for copying permission


# [todo] - command line arg for tags, ignore, createrc, other options
# [todo] - command line for file/folder (allow individual)
# [todo] - add priority listing for tags and todo
# [todo] - generate .html file with report
# [todo] - add text editor/jump to code for each item in .html report
# [todo] - if x is placed in todo [!] then move it to separate file
# [todo] - have option to export tags/todo to github/bitbucket issue tracker
# [todo] - add function and ask user to send phonehome to keep track of stats
# [todo] - changelist such that if a tag is replaced with its matching fixed
#		   remove issue (resolve) on github/bitbucket, put it into list of fixed
#		   issues, and modify source to remove tag (optional) 
# [todo] - store in separate file or parse every time? (thinking parse)
# [todo] - tell when directory changes with some header
# [todo] - support other comment types
# [todo] - change @IGNOREDIR to hash instead of array for efficiency
# [todo] - only allow user to check executing users files (setuid exploit)
# [todo] - allow single files in rc file (use different [files] section?)
# [todo] - add check for color support, modify print that way
# [todo] - store base html page on github, do a curl for header
# 		   append actual content to file
# 		   curl footer from github, boom html
# [todo] - add support for running outside of project directory (fix stripping of leading . / )

###########################################################
# Global parameters 
###########################################################

# For testing
#use strict;
#use warnings;

# For color print outs
use Term::ANSIColor qw(:constants);

# Route Ctrl-C to cExit to clean up results 
$SIG{'INT'} = \&cExit;

# For debugging (print data structures)
use Data::Dumper;

# App Config
my $DEBUG = 0;
my $RCNAME = ".watsonrc";		# Change config file name
my $TMPOUT = ".watsonresults";	# Change tmp file name

# Global variables
my @DIRS;
my @FILES;
my @TAGS;
my @IGNORE;
my @STRUCTURE;
my $REMOTEISSUE = 0;
my $GITHUB_API;
my $GITHUB_REPO;
my $BITBUCKET_API;
my $BITBUCKET_REPO;
my $MAX_DEPTH = 0;
my $DEPTH = 0;
my $IGNORE_RC_DIRS = 0;
my $IGNORE_RC_FILES = 0;
my $IGNORE_RC_TAGS = 0;
my $IGNORE_RC_IGNORE = 0;
my $HASLESS = 0;
my $HASCURL = 0;
my $LESSOUT;


use constant GITHUB => 0;
use constant BITBUCKET => 1;


#----------------------------------------------------------
###########################################################
# Main Program 
###########################################################
#----------------------------------------------------------

checkLess();
checkcURL();
printHeader();
parseCommandLine();
checkConfig();
parseConfig();
startScan();
createReport();


#----------------------------------------------------------
###########################################################
# Functions 
###########################################################
#----------------------------------------------------------


###########################################################
# Header Print 
###########################################################

# Print watson header
sub printHeader {
	wprint(BOLD "------------------------------\n");
	wprint(BOLD "watson", RESET);
	wprint(" - ");
	wprint(BOLD YELLOW "inline issue manager\n", RESET);
	wprint(BOLD "------------------------------\n\n");
	return 1;
}


###########################################################
# Help Print 
###########################################################

# Print watson help 
sub printHelp {

	print "Usage: watson [OPTION]...\n";
	print "Running watson with no arguments will parse with settings in RC file\n";
	print "If no RC file exists, default RC file will be created\n";

	print "\n";
	print "   -d, --dirs			list of directories to search in\n";
	print "   -f, --files			list of files to search in\n";
	print "   -h, --help			print help\n";
	print "   -i, --ignore			list of files, directories, or types to ignore\n";
	print "   -m, --max-depth		max depth for recursive directory parsing\n";
	print "   -r, --remote			create OAuth token for [github:bitbucket]\n";
	print "   -t, --tags			list of tags to search for\n";
	print "   -v, --version		print watson version and info\n";
	print "\n";

	print "Any number of files, tags, dirs, and ignores can be listed after flag\n";
	print "To use *.filetype identifier, encapsulate in \"\" to avoid shell substitutions \n";
	print "\n";

	print "Report bugs to: watson\@goosecode.com\n";
	print "watson home page: <http://goosecode.com/projects/watson>\n";
	print "[goosecode] labs | 2012-2013\n";

	return 1;
}


###########################################################
# Help Print 
###########################################################

# Print watson help 
sub printVersion {

	print "watson v1.1\n";
	print "Copyright (c) 2012-2013 goosecode labs\n";
	print "Licensed under MIT, see LICENSE for details\n";
	print "\n";

	print "Written by nhmood and others, see <http://goosecode.com/projects/watson>\n";
	return 1;
}


###########################################################
# Clean Exit
###########################################################

# Clean exit function that removes temp files
sub cExit {
	my ($ex) = @_;
	# Clean up temp file(s)
	system("rm $TMPOUT > /dev/null 2>&1");

	# If exit status is INT(terupt), set to 1 and print newline	
	if ($ex eq "INT"){ $ex = 1; print "\n"; }
	exit $ex;
}


###########################################################
# Debug Print
###########################################################

# Debug print statements that are only enabled
# when debug flag is set (top of file)
sub debugPrint {
	if ($DEBUG){
		print @_;
	}
	return 1;
}


###########################################################
# Output Print
###########################################################

# If system has less, dump all output to .tmp file and use less
# If no less, just print straight to stdout
sub wprint {
	my ($line) = @_;
	
	if ($HASLESS){
		print $LESSOUT "$line";
		return 1;
	}
	else {
		print "$line";
		return 0;
	}
}


###########################################################
# Unix less Checker
###########################################################

# Check to see if system has less
# If so, set flag and open tmp file
sub checkLess {
	if (! system("which less > /dev/null 2>&1") ){
		open($LESSOUT, "+>", $TMPOUT);
		$HASLESS = 1;
		return 1;
	}
	else {
		return 0;
	}
}


###########################################################
# cURL Checker
###########################################################

# Check to see if system has cURL
# If so, set flag
sub checkcURL {
	if (! system("which curl > /dev/null 2>&1") ){
		$HASCURL = 1;
		return 1;
	}
	else {
		return 0;
	}
}


###########################################################
# Directory checker  
###########################################################

# checkDir - checks if directory can be opened 
# Different from just using -d, checks if able to OPEN
sub checkDir {
	my ($dir) = @_;
	# Error check for input
	if (length($dir) == 0){
		wprint("No directories specified.\n");
		return 0;
	}
	# Check if directory can be opened
	my $success = opendir(my $tDIR, $dir);
	if (!$success){
		wprint("Cannot open dir: |$dir|, skipping.\n");
		return 0;
	}

	closedir($tDIR);
	debugPrint("|$dir| exists and opened successfully.\n");
	return 1;
}


###########################################################
# File checker  
###########################################################

# checkFile - checks if file can be opened
# Different from just using -f, checks if able to OPEN
sub checkFile {
	my ($file) = @_;
	# Error check for input
	if (length($file) == 0){
		wprint("No file specified.\n");
		return 0;
	}

	# Check if file can be opened
	my $success = open(my $tFILE, $file);
	if (!$success){
		wprint("Could not open |$file|, skipping.\n");
		return 0;
	}

	close($tFILE);
	debugPrint("|$file| exists and opened successfully.\n");
	return 1;
}


###########################################################
# Config file check
###########################################################

# Check for config file in same dir as watson
# If it doesn't exist, create the default one
sub checkConfig {
	# Should have individual .rc for each dir that watson is in
	# This allows you to keep different preferences for different projects
	
	# Check for rc
	# -z checks if filesize is 0
	debugPrint("[Checking for $RCNAME] \n");
	if (! -e "$RCNAME"){
		debugPrint("$RCNAME not found! \n");
		debugPrint("Creating default $RCNAME \n");
	
		# Create default rc
		createRC("$RCNAME");
		return 0;
	}
	else {
		debugPrint("$RCNAME found \n\n");
		return 1;
	}
}


###########################################################
# Default config file writer 
###########################################################

# Create default RC file with some generic settings
sub createRC {
	my ($file_name) = @_;
	open(my $file, "+>>", "$RCNAME");
# [fixme] - Figure out a way to indent this?
my $rcdefault = <<EOF; 
# watson rc
# watson - inline issue manager
# [goosecode] labs / 2012


# Directories 
[dirs] 
./

 
# Tags 
[tags] 
fixme 
reviewme
todo


# Ignores
[ignore]
.git

EOF

	debugPrint($rcdefault);
	# Print default rc above to specified file
	# [fixme] - Get return 
	my $success = print $file $rcdefault;
	close($file);
	return $success;
}


###########################################################
# Command line parser 
###########################################################

# Parse command line arguments
sub parseCommandLine {
	debugPrint("[Checking CL args]\n");
	debugPrint("Total args: ", $#ARGV + 1, "\n");

	my @opts = ("-d", "--dirs", 
				"-f", "--files",
				"-h", "--help", 
				"-t", "--tags",
				"-m", "--max-depth",
				"-i", "--ignore",
				"-r", "--remote"); 


	# Check number of command lines, skip if invalid
	if ($#ARGV > -1){
		for (my $i = 0; $i < $#ARGV + 1; $i++){
			debugPrint("Main Index: $i: $ARGV[$i]\n");		
		
			if ($ARGV[$i] eq "-h" || $ARGV[$i] eq "--help"){
				debugPrint("Help flag passed\n");
				printHelp();		
				cExit(0);
			}

			if ($ARGV[$i] eq "-v" || $ARGV[$i] eq "--version"){
				debugPrint("Version flag passed\n");
				printVersion();
				cExit(0);
			}
	
			if ($ARGV[$i] eq "-m" || $ARGV[$i] eq "--max-depth"){
				debugPrint("Max Depth flag passed\n");
				# Check to make sure next param is a valid number (non-negative)
				if ( $ARGV[$i + 1] =~ m/^([0-9]+)$/ ){
					$MAX_DEPTH = $ARGV[$i + 1];
					debugPrint("Valid max depth: $MAX_DEPTH\n");
				}
				else {
					wprint(BOLD "[ ", RESET);
					wprint(BOLD MAGENTA "! ", RESET);
					wprint(BOLD "] ", RESET);
					wprint("--> ", RESET);
					wprint("Invalid max depth passed\n");
				}
				
				# Move index to two after (flag and value)
				$i = $i + 2;

			}

			if ($ARGV[$i] eq "-r" || $ARGV[$i] eq "--remote"){
				debugPrint("Remote Flag passed\n");

				# When generating OAuth Token for github/bitbucket
				# no other params should be passed
				if ($i != 0 || $#ARGV > 1){
					debugPrint("Not the first flag, exiting\n");
					print BOLD "[ ", RESET;
					print BOLD RED "x ", RESET;
					print BOLD "] ", RESET;
					print "Please run remote flag alone to generate Github/Bitbucket OAuth token\n";
					print "      See help for more details\n";
					cExit(1);
				}
				
				# Can only do this if we have cURL on the system
				if (! $HASCURL ){
					print BOLD "[ ", RESET;
					print BOLD RED "x ", RESET;
					print BOLD "] ", RESET;
					print "It looks like you don't have cURL\n";
					print "      We currently only support remote issues if you have cURL\n";
					print "      Make sure cURL is installed and in your PATH\n";
					cExit(1);
				}

				if 	  ($ARGV[$i + 1] eq "bitbucket"){ gitSetup(BITBUCKET); }
			   	elsif ($ARGV[$i + 1] eq "github"   ){ gitSetup(GITHUB); }
				else  {
						print BOLD "[ ", RESET;
						print BOLD RED "x ", RESET;
						print BOLD "] ", RESET;
						print BOLD "Please specify either Github or Bitbucket\n", RESET;
						print "      That's all we support right now :(\n";
						print "      See help for more details\n";
						cExit(1);
				}
				
			}


			if ($ARGV[$i] eq "-d" || $ARGV[$i] eq "--dirs"){
				debugPrint("Dir flag passed\n");
				# Keep track of number of args for when we exit loop
				my $count = 0;

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
		
						debugPrint("Dir Index: $j: $ARGV[$j]\n");
						$count++;	
						if (checkDir($ARGV[$j])){
	
							debugPrint("dirflag: {$ARGV[$j]} valid directory, added from CL.\n");
	
							# If we ever get into this, means CL passed
							# Set RC ignore so we don't look at rc
							debugPrint("Ignoring RC Files/Dirs\n\n");
							$IGNORE_RC_DIRS = 1;
	
							# Remove trailing slashes
							$ARGV[$j] =~ s/(\/)+$//;
							push(@DIRS, $ARGV[$j]);
						}
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
				
			}
		

			if ($ARGV[$i] eq "-f" || $ARGV[$i] eq "--files"){
				debugPrint("File flag passed\n");
				# Keep track of number of args for when we exit loop
				my $count = 0;	

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
			
						debugPrint("File Index: $j: $ARGV[$j]\n");
						$count++;	
						if (checkFile($ARGV[$j])){
					
							debugPrint("fileflag: {$ARGV[$j]} valid file, added from CL.\n");	
	
							# If we ever get into this, means CL passed
							# Set RC ignore so we don't look at rc
							debugPrint("Ignoring RC Files/Dirs\n\n");
							$IGNORE_RC_FILES = 1;
	
							push(@FILES, $ARGV[$j]);
						}
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
			}
	
	
			if ($ARGV[$i] eq "-t" || $ARGV[$i] eq "--tags"){
				debugPrint("Tag flag passed\n");
				# Keep track of number of args for when we exit loop
				my $count = 0;

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
					
						debugPrint("Tag Index: $j: $ARGV[$j]\n");
						$count++;	
						
						debugPrint("tagflag: {$ARGV[$j]} added from CL.\n");	
	
						# If we ever get into this, means CL passed
						# Set RC ignore so we don't look at rc
						debugPrint("Ignoring RC tags\n\n");
						$IGNORE_RC_TAGS = 1;
	
						push(@TAGS, $ARGV[$j]);
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
			}
	

			if ($ARGV[$i] eq "-i" || $ARGV[$i] eq "--ignore"){
				debugPrint("Ignore flag passed\n");
				# Keep track of number of args for when we exit loop				
				my $count = 0;

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
					
						debugPrint("Ignore Index: $j: $ARGV[$j]\n");
						$count++;	
						
						debugPrint("ignoreflag: {$ARGV[$j]} added from CL.\n");	
	
						# If we ever get into this, means CL passed
						# Set RC ignore so we don't look at rc
						debugPrint("Ignoring RC ignore\n\n");
						$IGNORE_RC_IGNORE = 1;
	
						push(@IGNORE, $ARGV[$j]);
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
			}
		}
	}
	else {
		debugPrint("No command line arguments passed.\n\n");	
	}
	return 1;
}


###########################################################
# Config file parser
###########################################################

# Go through config file and determine dirs, tags, and ignores to use
sub parseConfig {
	# Parse rc
	debugPrint("Parsing $RCNAME\n");
	
	open(my $rc, "<", "$RCNAME");
	
	# Add . and .. and .git to ignorelist 
	push(@IGNORE, ".");
	push(@IGNORE, "..");
	push(@IGNORE, "*.swp");
	push(@IGNORE, $TMPOUT);
	
	
	# Read rc line by line
	my $section = "";
	while (my $line = <$rc>){
	    debugPrint($line);
	    
		# Ignore full line comments
	    if ($line !~ m/^#/ && $line =~ /\S/){
			# Regex to find [section], store into $section and continue to the
			# next line until a new section
			if ($line =~ /^\[(\w+)\]/){
			    $section = $1;
			    next;
			}
	    	
			# If @DIRS or @FILES wasn't populated by CL args, populate from rc
			if ($section eq "dirs"){
			    if ($IGNORE_RC_DIRS == 1 || $IGNORE_RC_FILES == 1) {
					debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
			    }
			    else {
	    	        # Regex for dirs, then push to @DIRS
					$line =~ /^((\.?\/?\w?+\/?)+)/;
					$line = $1;
					$line =~ s/(\/)+$//;
					debugPrint("dirs: $line added from rc. \n");
					push(@DIRS, $line);
			    }
			}
			
			# If @TAGS wasn't populated by CL args, populate from rc
			elsif ($section eq "tags"){
			    if ($IGNORE_RC_TAGS == 1) {
					debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
			    }
				else {
					# Regex for tags, then push to @TAGS
			    	$line =~ /^(\w+( \| [0-9])?)/;
			    	debugPrint("tags: $1 added from rc. \n");
			    	push(@TAGS, $1);
				}
			}
	
			# If @IGNORE wasn't populated by CL args, populate from rc
			elsif ($section eq "ignore"){
			    if ($IGNORE_RC_IGNORE == 1) {
					debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
			    }
				else {
					# Regex for dirs to ignore, then push to @IGNOREDIR

					$line =~ /^((\/?\w+\/?)+)/;
					$line = $1;
					$line =~ s/(\/)+$//;
					debugPrint("ignore: $line added from rc.\n");
					push(@IGNORE, $line);
				}
			}
			elsif ($section eq "github"){
				# No need for regex on API key
				debugPrint("Github API: $line\n");
				$GITHUB_API = $line;
				$REMOTEISSUE = 1;
			}
			elsif ($section eq "bitbucket"){
				# No need for regex on API key
				debugPrint("Bitbucket API: $line\n");
				$BITBUCKET_API = $line;
				$REMOTEISSUE = 1;
			}
			elsif ($section eq "githubrepo"){
				# No need for regex on repo
				debugPrint("Github Repo: $line\n");
				$GITHUB_REPO = $line;
				$REMOTEISSUE = 1;
			}
			elsif ($sectiono eq "bitbucketrepo"){
				# No need for regex on repo
				debugPrint("Bitbucket Repo: $line\n");
				$BITBUCKET_REPO = $line;
				$REMOTEISSUE = 1;
			}

	    } 
	}

	debugPrint("\n\n\n");
	close($rc);
	return 1;
}	


###########################################################
# File/Folder Parser Wrapper
###########################################################

# Start going through all files and subdirs of specified folder
sub startScan{
	
	# If files passed to command line, push those to structure
	# Have to populate structure this way to print properly
	if ($IGNORE_RC_FILES){
		# For each file obtained from CL (if any) parse file
		# Create proper structure for files so we can push to @STRUCTURE
		my $structure = {};
		my @tfiles = ();
		foreach my $file (@FILES){
			push(@tfiles, parseFile($file));
		}
		
		$structure->{files} = \@tfiles;
		push(@STRUCTURE, $structure);
	}

	# For each directory obtained from rc or CL, look for files in them
	# This will always be valid, not condition like files above
	foreach my $dir (@DIRS){
		push(@STRUCTURE, parseDirs($dir));
		# Reset DEPTH on directories specified (not dirs found within)
		$DEPTH = 0;
	}

	wprint("\n");
	return 1;
}


###########################################################
# Directory Parser
###########################################################

# Look through directory for files to parse
sub parseDirs {
	my ($dir) = @_;
	debugPrint("parseDirs: |$dir|\n");

	my @pdirs;		# subdirectories found
	my @pfiles;		# files found

	

	# Error check for input
	if (!checkDir($dir)){
		return 0;
	}
	
	# [fixme] - add option to stop from going deeper dirs (depth?)
	# Loop through all entries in directory
	debugPrint("Looping through all files/folders in |$dir|\n");

	# Open dir and get list of all files	
	opendir(my $wd, $dir);
	my @dirlist = sort(readdir($wd));

	foreach my $entry (@dirlist){
		# Create singular $path var to parse
		# Remove trailing slashes
		$dir =~ s/^(\/)+$//;
		
		# Combine dir and entry to make full path
		my $path = "$dir/$entry";

		# Remove leading ., /, or ./
		$path =~ s/^((\.)?(\/)?)//; 

		debugPrint("path: |$path|\n");

		# Make sure it isn't part of ignored list
		# If it is, set to "", won't pass dir/file check
		# [reviewme] - Should we warn users when file is ignored on stdout?
		foreach my $ignore (@IGNORE){
			# Check for any *.type in ignore list (list .swp)
			# Regex to see if extension is .type, ignore if so 
			if ( substr($ignore, 0, 1) eq "*" ){
				my $ignoretype = substr($ignore, 1);
				if ( $entry =~ m/$ignoretype$/ ){
					debugPrint("|$path| is on the ignore list, setting to nothing\n");
					$path = "";
				}
			}
			elsif ("$entry" eq "$ignore" | "$path" eq "$ignore"){
				debugPrint("|$path| is on the ignore list, setting to nothing\n");
				$path = "";
				last;
			}
		}
		
		# Check if entry is a file, if so parse
		if (-f "$path"){
			debugPrint("|$path| is a file!\n");
			push(@pfiles, parseFile("$path"));
		}

		# Check if entry is dir, if so parse
		elsif (-d "$path"){
			debugPrint("|$path| is a dir!\n");

			# If MAX_DEPTH is 0, no limit on subdirs
			# Increment DEPTH, compare with MAX_DEPTH
			# If less than depth, parse dir, else ignore
			$DEPTH++;
			debugPrint("Folder depth: $DEPTH\n");
			if ($MAX_DEPTH == 0){
				debugPrint("No max depth, parsing folders\n");
				push(@pdirs, parseDirs("$path"));
			}
			elsif ($DEPTH < $MAX_DEPTH){
				debugPrint("Depth less than Max depth, parsing folder\n");
				push(@pdirs, parseDirs("$path"));
			}
			else {
				debugPrint("Depth greater than Max depth, ignoring\n");
			}

		}

		# Add directory to ignore list so it isn't repeated again
		push(@IGNORE, $path);
		
	}

	closedir($wd);
	# Create has to hold all parsed files and folders
	my $structure = {};

	# Still confused as to what this is actually doing but...
	# Storing an array of hashes into structure->file hash
	# I THINK?? that because the array consists of hashes (references)
	# the \@pfiles will copy the actual values (or keep the references alive?)
	# Either way, some scoping thing is solved with \@
	
	$structure->{files} = \@pfiles;
	$structure->{dirs} = \@pdirs;

	return $structure;
}


###########################################################
# File Parser
###########################################################

sub parseFile {
	# [fixme] - need a better check for valid files (when using @_)
	my ($file) = @_;
	debugPrint("parseFile: |$file|\n");

	# Error check for input
	if (!checkFile($file)){
		return 0;
	}

	# Get filetype and set corresponding comment type
	my $comment = getComment($file);
	if (!$comment){
		wprint(BOLD "[ ", RESET);
		wprint(BOLD MAGENTA "! ", RESET);
		wprint(BOLD "] ", RESET);
		wprint("--> ", RESET);
		wprint("Couldn't determine filetype for $file, using # as comment\n", RESET);
		$comment = "#";
	}

	# Open file and seek to beginning
	open(my $wf, "<", $file);
	seek($wf, 0, 0);						 

	# Initialize tag arrays so they are globally avaliable
	foreach my $tag (@TAGS){
	    debugPrint("Creating array named $tag \n");
	    @{$tag};
	}

	# Read source file line by line
	my $linecount = 0;
	while (my $line = <$wf>){
	    $linecount++;
	    # Find any comment line with [tag] - text (any comb of space and #)
	    if ($line =~ /\s*($comment)+\s*\[(\S+)\]\s*-\s*(.+)/) {
			my $fissue = $3;
			my $ftag = $2;
			debugPrint("Issue found!\n");
			debugPrint("Tag: $ftag\n");		
			debugPrint("Issue: $fissue\n");
		
			foreach my $tag (@TAGS) {
		    	if ($ftag eq $tag) {
					# Create hash for each issue found (for each tag)
					my $issue = {};
					$issue->{linenumber} = $linecount;
					$issue->{comment} = $fissue;
					push(@{$tag}, $issue);
		    	}
			}
	    }
	}

	#[fixme] - change name to issueList
	my $issueList = {};
	$issueList->{filename} = "$file";
	
	# Toss on each tag found into the file's hash
	foreach my $tag (@TAGS){
	       	$issueList->{$tag} = [@{$tag}];
		debugPrint(Dumper($issueList));
		undef @{$tag};       		
	}
	return $issueList;
}


###########################################################
# Comment setter
###########################################################

# Determine comment type from file extension
sub getComment {
	my ($file) = @_;
	debugPrint("Getting comment type\n");

	# Grab the ending extension (.something)
	# Check to see whether it is recognized and set comment type
	# If unrecognized, try to grab next .something extension
	# This is to account for file.cpp.1 or file.cpp.bak, ect
	
	while ( (my $ext) = $file =~ m/(\.(\w+))$/){
		# Regex for last extension
		debugPrint("Extension: $ext\n");

		# Determine file type
		# Not using switch/case for compatibility...
		
		# C / C++
		# [todo] - add /* style comment
		if ( $ext eq ".cpp" || $ext eq ".cc" ||  $ext eq ".c" || $ext eq ".h"){
			debugPrint("Comment type is: //\n");
			return "//";
		}
		# Bash / Ruby / Perl	
		elsif ( $ext eq ".sh" || $ext eq ".rb" || $ext eq ".pl"){
			debugPrint("Comment type is: #\n");
			return "#";
		}
		# Can't recognize extension, keep looping
		else {
			$file =~ s/(\.(\w+))$//;
			debugPrint("Didn't recognize, new file: $file\n");
		}
	}
	
	# Didn't find any match, return error (and just use #)
	return 0;
}


###########################################################
# Result Printer Wrapper
###########################################################

# Format the parsed file data and output it nicely
sub createReport {
	# Display output for each file parsed 
	foreach my $entry (@STRUCTURE){
		printResults($entry);
	}
	
	if ($HASLESS){
		system("less $TMPOUT");
		close($LESSOUT);
		system("rm $TMPOUT > /dev/null 2>&1");
	}
	return 1;
}


###########################################################
# Individual Result Printer
###########################################################

# Print results from parsing all pretty and stuff
sub printResults {
	my ($entry) = @_;
	# Go through and print info for all files first
	for (my $i = 0; $i < scalar( @{$entry->{files}}); $i++){

		# [fixme] - Same foreach performed below, combine somehow?

		# Go through and see if there are any issues with given file
		# Sets print color and whether to continue to print
		my $issueflag = 0; 
		foreach my $tag (@TAGS){
			if (scalar( @{$entry->{files}[$i]->{$tag}})){
				$issueflag++;
			}
		}
		
		if ($issueflag){
			wprint("\n");
			wprint(BOLD "[ ", RESET);
			wprint(BOLD RED "x ", RESET);
			wprint(BOLD "] ", RESET);
			wprint(UNDERLINE BOLD RED "$entry->{files}[$i]->{filename}", RESET);
		}
		else {
			wprint(BOLD "[ ", RESET);
			wprint(BOLD GREEN "o ", RESET);
			wprint(BOLD "] ", RESET);
			wprint(UNDERLINE BOLD GREEN "$entry->{files}[$i]->{filename}", RESET);
		}

		wprint("\n");
		
		# If there are no issues, don't print anything (go to next file)
		# Else, continue on and print the issues
		($issueflag > 0) ? (1) : (next);	

		# Cycle through all tags and print issues for each	
		foreach my $tag (@TAGS){
		
			# If no issues in tag, don't print	
			if (!scalar( @{$entry->{files}[$i]->{$tag}})){
				next;
			}
		
			# Print tag, line #, and issue	
			wprint(BOLD  "\[ ", RESET);
			wprint(BOLD BLUE "$tag", RESET);
			wprint(BOLD  " \]\n", RESET);

			for (my $j = 0; $j < scalar( @{$entry->{files}[$i]->{$tag}}); $j++){
				wprint(WHITE "  line $entry->{files}[$i]->{$tag}[$j]->{linenumber} - ", RESET);
				wprint(BOLD "$entry->{files}[$i]->{$tag}[$j]->{comment} \n", RESET); 
			}
			wprint("\n");
		}
	}

	for (my $i = 0; $i < scalar( @{$entry->{dirs}}); $i++){
		printResults($entry->{dirs}[$i]);
	}
	return 1;
}


###########################################################
# Git Setup
###########################################################

# Obtain API key for either Github or Bitbucket
sub gitSetup {
	my ($git) = @_;
	my $gitstr = $git ? "Bitbucket" : "Github";

	# JSON Response var
	my $js;

	# [fixme] - Same code as header just without wprint, make modular
	print(BOLD "------------------------------\n");
	print(BOLD "watson", RESET);
	print(" - ");
	print(BOLD YELLOW "inline issue manager\n", RESET);
	print(BOLD "------------------------------\n\n");

	# [fixme] - Make modular status printer?
	print BOLD "[ ", RESET;
	print BOLD GREEN "+ ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Obtaining OAuth Token for $gitstr...\n", RESET;

	# Parse config to make sure no previous API exists
	checkConfig() ? parseConfig() : true;

	if (($git ? $BITBUCKET_API  : $GITHUB_API) ne "" ||
		($git ? $BITBUCKET_REPO : $GITHUB_REPO) ne ""){
		print BOLD "[ ", RESET;
		print BOLD RED "! ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Previous $gitstr API + repo is in RC, are you sure you want to overwrite?\n", RESET;
		print "      (Y)es/(N)o: ";

		my $overwrite = <STDIN>;
		chomp $overwrite;
		print "\n";
		
		if ($overwrite eq "" || uc($overwrite) eq "NO" ||
			uc($overwrite) eq "N"){
			print BOLD "[ ", RESET;
			print BOLD RED "x ", RESET;
			print BOLD "] ", RESET;
			print BOLD "Not overwriting current $gitstr API + repo info\n", RESET;
			cExit(1);
		}
	}
	

	print BOLD "[ ", RESET;
	print BOLD YELLOW "! ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Access to your $gitstr account required to make/update issues\n", RESET;
   	
	print "      See help or README for more details on Github/Bitbucket access\n";	
	print "      (Or just take a peek at line ~1095)\n\n";


	# Get username, clear newlines surrounding text
	# If blank, give error
	print BOLD "Username: ", RESET;
	my $username = <STDIN>;
	chomp $username;
	if ($username eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter your username!\n", RESET;
		cExit(1);
	}

	# cURL to get OAuth Token, returns JSON
	print BOLD;
	if ($git == BITBUCKET){
		# [todo] - Bitbucket API Implementation
	}
	else {
		my $call = "curl -s -i " .
				   "-u $username " .
				   "-d '{\"scopes\": [\"repo\"], \"note\": \"watson\"}' " .
				   "https://api.github.com/authorizations";
		my $response = `$call`;
		$js = parseJSON($response);
	}
	print "\n", RESET;

	
	if ($js->{"Status"} =~ m/201 Created/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Obtained OAuth Token\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to obtain OAuth Token\n", RESET;
		print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}

	# Set API key for use later so we don't have to parse config
	# [reviewme] - Maybe we should just parse config?
	if ($git == BITBUCKET){
		$BITBUCKET_API = $js->{"token"};
	}
	else {
		$GITHUB_API = $js->{"token"};
	}

	# Get repo information
	# If blank, give error
	print BOLD "[ ", RESET;
	print BOLD YELLOW "! ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Repo information required\n", RESET;
	print "      Please provide user that repo is under followed by repo\n";
	print "      e.g. user: nhmood, repo: watson (case sensitive)\n";
	print "      See help or README for more details on Github/Bitbucket access\n\n";	

	print BOLD "User: ", RESET;
	my $user = <STDIN>;
	chomp $user;
	if ($user eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter the user the repo is under!\n", RESET;
		cExit(1);
	}
	print BOLD "Repo: ", RESET;
	my $repo = <STDIN>;
	chomp $repo;
	if ($repo eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter the repo name!\n", RESET;
		cExit(1);
	}

	# Try to get issue list from specified repo
	if ($git == BITBUCKET){
		# [todo] - Bitbucket API Implementation
	}
	else {
		my $call = "curl -s -i " .
				   "-H 'Authorization: token $GITHUB_API' " .
				   "https://api.github.com/repos/$user/$repo/issues";
		my $response = `$call`;
		$js = parseJSON($response);
	}
	print "\n";

	
	if ($js->{"Status"} =~ m/200 OK/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Repo successfully accessed\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to access /repo/$user/$repo\n", RESET;
		print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}
	print "\n";


	# [fixme] - Make modular status printer?
	print BOLD "[ ", RESET;
	print BOLD GREEN "+ ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Creating label for watson on $gitstr...\n", RESET;

	# Create label for watson
	if ($git == BITBUCKET){
		# [todo] - Bitbucket API Implementation
	}
	elsif ($git == GITHUB){
		my $call = "curl -s -i " .
			       "-H 'Authorization: token $GITHUB_API' " .
			       "https://api.github.com/repos/$user/$repo/labels " .
			       "-d '{" .
			       		"\"name\" : \"watson\"," .
			       		"\"color\" : \"00AEEF\" }'";
		my $response = `$call`;
		$js = parseJSON($response);
	}


	if ($js->{"Status"} =~ m/201 Created/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Label successfully created\n";
	}
	elsif ($js->{"code"} =~ m/already_exists/){
		print BOLD "[ ", RESET;
		print BOLD YELLOW "! ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Label already exists\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to access /repo/$user/$repo\n", RESET;
		print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}
	print "\n";



	# Check if RC exists
	# If it exists, basically replicate it and remove [github/bitbucket tag]
	if (checkConfig()){
		debugPrint("Config exists, copying\n");
		open(my $in, "<", "$RCNAME");
		open(my $out, ">", "$RCNAME.new");
		my $section = "";
		my $nlc = 0;
		while (my $line = <$in>){
			debugPrint("$line\n");
			# Regex for section
			if ($line =~ /^\[(\w+)\]/){
			    $section = $1;
			}
		
						
			# Check for newlines
			# If we already have 2 newlines before any actual content, skip
			# This is just to make the RC file output nicer looking
			if ($line eq "\n"){
				debugPrint("Newline found\n");
				if (++$nlc < 3){
					debugPrint("Less than 3 newlines so far, let it print\n");
					print $out $line;
				}
			}
			# If not in bitbucket or github section, safe to copy
			# make $gitstr lowercase and check that + repo 
			elsif ($section ne (lc($gitstr)) &&
				   $section ne (lc($gitstr . "repo"))){
				
				debugPrint("Not in git section, copying to new rc\n");
				print $out $line;
				# Reset newline count
				$nlc = 0;
			}

			debugPrint("line: $line");
			debugPrint("nlc: $nlc\n");


		}

		# Remove old RC file and replace with new one
		system("rm $RCNAME > /dev/null 2>&1");
		system("cp $RCNAME.new $RCNAME > /dev/null 2>&1");	
		system("rm $RCNAME.new > /dev/null 2>&1");
	}

	# Append API token to end of file (old or new, doesn't matter now)
	open(my $file, "+>>", "$RCNAME");
	print $file "[", ($git ? "bitbucket" : "github"), "]\n";
	print $file ($git ? $BITBUCKET_API : $GITHUB_API);
	print $file "\n\n\n";
	print $file "[", ($git ? "bitbucketrepo" : "githubrepo"), "]\n";
	print $file "$user/$repo";
	print $file "\n";
	close($file);



	print BOLD "[ ", RESET;
	print BOLD GREEN "o ", RESET;
	print BOLD "] ", RESET;
	print BOLD "$gitstr successfully setup\n", RESET;
	print "      Issues will now automatically be updated on $gitstr by default\n";
	print "      Use -l, --local to not update against $gitstr\n";
	print "      See help or README for more details on Github/Bitbucket access\n";	
	print "\n";
	cExit(0);
}


###########################################################
# JSON Parser
###########################################################

# Parse JSON response from github/bitbucket issue requests
sub parseJSON {
	my ($json) = @_;

	debugPrint("JSON Parser");

	# Clean up text, separate with : delimiter
	# Throw data into hash
	my $js = {};
	my @lines = split /\n/, $json;
	foreach my $line (@lines){
		my $ind = index($line, ":");
		if ($ind != -1){
			my $field = substr($line, 0, $ind);
			my $value = substr($line, $ind + 1);
			if ($value ne "{" || $value ne "["){
				# Remove trailing spaces, }, ], ,s and all ""
				$field =~ s/^(\s+)}?]?//g;
				$field =~ s/\"?,?//g;

				$value =~ s/^(\s+)\{?\[?//g;
				$value =~ s/\"?,?//g;

				debugPrint("field: $field\n");
				debugPrint("value: $value\n");
				$js->{$field} = $value;
			}
		}
	}
	return $js;
}

